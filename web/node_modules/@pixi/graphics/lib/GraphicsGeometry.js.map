{"version":3,"file":"GraphicsGeometry.js","sources":["../src/GraphicsGeometry.ts"],"sourcesContent":["import {\n    buildLine,\n    buildPoly,\n    BatchPart,\n    FILL_COMMANDS,\n    BATCH_POOL,\n    DRAW_CALL_POOL,\n} from './utils';\n\nimport {\n    BatchGeometry,\n    BatchDrawCall,\n    BatchTextureArray,\n    BaseTexture,\n    DRAW_MODES,\n    WRAP_MODES,\n    Point,\n    utils,\n} from '@pixi/core';\n\nimport { GraphicsData } from './GraphicsData';\nimport { Bounds } from '@pixi/display';\n\nimport type { Texture, Circle, Ellipse, Polygon, Rectangle, RoundedRectangle, IPointData, Matrix } from '@pixi/core';\nimport type { FillStyle } from './styles/FillStyle';\nimport type { LineStyle } from './styles/LineStyle';\n\n/*\n * Complex shape type\n * @todo Move to Math shapes\n */\ntype IShape = Circle | Ellipse | Polygon | Rectangle | RoundedRectangle;\n\nconst tmpPoint = new Point();\n\n/**\n * The Graphics class contains methods used to draw primitive shapes such as lines, circles and\n * rectangles to the display, and to color and fill them.\n *\n * GraphicsGeometry is designed to not be continually updating the geometry since it's expensive\n * to re-tesselate using **earcut**. Consider using {@link PIXI.Mesh} for this use-case, it's much faster.\n * @memberof PIXI\n */\nexport class GraphicsGeometry extends BatchGeometry\n{\n    /**\n     * The maximum number of points to consider an object \"batchable\",\n     * able to be batched by the renderer's batch system.\n\\\n     */\n    public static BATCHABLE_SIZE = 100;\n\n    /** Minimal distance between points that are considered different. Affects line tesselation. */\n    public closePointEps = 1e-4;\n\n    /** Padding to add to the bounds. */\n    public boundsPadding = 0;\n\n    uvsFloat32: Float32Array = null;\n    indicesUint16: Uint16Array | Uint32Array = null;\n    batchable = false;\n\n    /** An array of points to draw, 2 numbers per point */\n    points: number[] = [];\n\n    /** The collection of colors */\n    colors: number[] = [];\n\n    /** The UVs collection */\n    uvs: number[] = [];\n\n    /** The indices of the vertices */\n    indices: number[] = [];\n\n    /** Reference to the texture IDs. */\n    textureIds: number[] = [];\n\n    /**\n     * The collection of drawn shapes.\n     * @member {PIXI.GraphicsData[]}\n     */\n    graphicsData: Array<GraphicsData> = [];\n\n    /**\n     * List of current draw calls drived from the batches.\n     * @member {PIXI.BatchDrawCall[]}\n     */\n    drawCalls: Array<BatchDrawCall> = [];\n\n    /** Batches need to regenerated if the geometry is updated. */\n    batchDirty = -1;\n\n    /**\n     * Intermediate abstract format sent to batch system.\n     * Can be converted to drawCalls or to batchable objects.\n     * @member {PIXI.graphicsUtils.BatchPart[]}\n     */\n    batches: Array<BatchPart> = [];\n\n    /** Used to detect if the graphics object has changed. */\n    protected dirty = 0;\n\n    /** Used to check if the cache is dirty. */\n    protected cacheDirty = -1;\n\n    /** Used to detect if we cleared the graphicsData. */\n    protected clearDirty = 0;\n\n    /** Index of the last batched shape in the stack of calls. */\n    protected shapeIndex = 0;\n\n    /** Cached bounds. */\n    protected _bounds: Bounds = new Bounds();\n\n    /** The bounds dirty flag. */\n    protected boundsDirty = -1;\n\n    // eslint-disable-next-line @typescript-eslint/no-useless-constructor\n    constructor()\n    {\n        super();\n    }\n\n    /**\n     * Get the current bounds of the graphic geometry.\n     * @readonly\n     */\n    public get bounds(): Bounds\n    {\n        this.updateBatches();\n\n        if (this.boundsDirty !== this.dirty)\n        {\n            this.boundsDirty = this.dirty;\n            this.calculateBounds();\n        }\n\n        return this._bounds;\n    }\n\n    /** Call if you changed graphicsData manually. Empties all batch buffers. */\n    protected invalidate(): void\n    {\n        this.boundsDirty = -1;\n        this.dirty++;\n        this.batchDirty++;\n        this.shapeIndex = 0;\n\n        this.points.length = 0;\n        this.colors.length = 0;\n        this.uvs.length = 0;\n        this.indices.length = 0;\n        this.textureIds.length = 0;\n\n        for (let i = 0; i < this.drawCalls.length; i++)\n        {\n            this.drawCalls[i].texArray.clear();\n            DRAW_CALL_POOL.push(this.drawCalls[i]);\n        }\n\n        this.drawCalls.length = 0;\n\n        for (let i = 0; i < this.batches.length; i++)\n        {\n            const batchPart = this.batches[i];\n\n            batchPart.reset();\n            BATCH_POOL.push(batchPart);\n        }\n\n        this.batches.length = 0;\n    }\n\n    /**\n     * Clears the graphics that were drawn to this Graphics object, and resets fill and line style settings.\n     * @returns - This GraphicsGeometry object. Good for chaining method calls\n     */\n    public clear(): GraphicsGeometry\n    {\n        if (this.graphicsData.length > 0)\n        {\n            this.invalidate();\n            this.clearDirty++;\n            this.graphicsData.length = 0;\n        }\n\n        return this;\n    }\n\n    /**\n     * Draws the given shape to this Graphics object. Can be any of Circle, Rectangle, Ellipse, Line or Polygon.\n     * @param {PIXI.Circle|PIXI.Ellipse|PIXI.Polygon|PIXI.Rectangle|PIXI.RoundedRectangle} shape - The shape object to draw.\n     * @param fillStyle - Defines style of the fill.\n     * @param lineStyle - Defines style of the lines.\n     * @param matrix - Transform applied to the points of the shape.\n     * @returns - Returns geometry for chaining.\n     */\n    public drawShape(\n        shape: IShape,\n        fillStyle: FillStyle = null,\n        lineStyle: LineStyle = null,\n        matrix: Matrix = null): GraphicsGeometry\n    {\n        const data = new GraphicsData(shape, fillStyle, lineStyle, matrix);\n\n        this.graphicsData.push(data);\n        this.dirty++;\n\n        return this;\n    }\n\n    /**\n     * Draws the given shape to this Graphics object. Can be any of Circle, Rectangle, Ellipse, Line or Polygon.\n     * @param {PIXI.Circle|PIXI.Ellipse|PIXI.Polygon|PIXI.Rectangle|PIXI.RoundedRectangle} shape - The shape object to draw.\n     * @param matrix - Transform applied to the points of the shape.\n     * @returns - Returns geometry for chaining.\n     */\n    public drawHole(shape: IShape, matrix: Matrix = null): GraphicsGeometry\n    {\n        if (!this.graphicsData.length)\n        {\n            return null;\n        }\n\n        const data = new GraphicsData(shape, null, null, matrix);\n\n        const lastShape = this.graphicsData[this.graphicsData.length - 1];\n\n        data.lineStyle = lastShape.lineStyle;\n\n        lastShape.holes.push(data);\n\n        this.dirty++;\n\n        return this;\n    }\n\n    /** Destroys the GraphicsGeometry object. */\n    public destroy(): void\n    {\n        super.destroy();\n\n        // destroy each of the GraphicsData objects\n        for (let i = 0; i < this.graphicsData.length; ++i)\n        {\n            this.graphicsData[i].destroy();\n        }\n\n        this.points.length = 0;\n        this.points = null;\n        this.colors.length = 0;\n        this.colors = null;\n        this.uvs.length = 0;\n        this.uvs = null;\n        this.indices.length = 0;\n        this.indices = null;\n        this.indexBuffer.destroy();\n        this.indexBuffer = null;\n        this.graphicsData.length = 0;\n        this.graphicsData = null;\n        this.drawCalls.length = 0;\n        this.drawCalls = null;\n        this.batches.length = 0;\n        this.batches = null;\n        this._bounds = null;\n    }\n\n    /**\n     * Check to see if a point is contained within this geometry.\n     * @param point - Point to check if it's contained.\n     * @returns {boolean} `true` if the point is contained within geometry.\n     */\n    public containsPoint(point: IPointData): boolean\n    {\n        const graphicsData = this.graphicsData;\n\n        for (let i = 0; i < graphicsData.length; ++i)\n        {\n            const data = graphicsData[i];\n\n            if (!data.fillStyle.visible)\n            {\n                continue;\n            }\n\n            // only deal with fills..\n            if (data.shape)\n            {\n                if (data.matrix)\n                {\n                    data.matrix.applyInverse(point, tmpPoint);\n                }\n                else\n                {\n                    tmpPoint.copyFrom(point);\n                }\n\n                if (data.shape.contains(tmpPoint.x, tmpPoint.y))\n                {\n                    let hitHole = false;\n\n                    if (data.holes)\n                    {\n                        for (let i = 0; i < data.holes.length; i++)\n                        {\n                            const hole = data.holes[i];\n\n                            if (hole.shape.contains(tmpPoint.x, tmpPoint.y))\n                            {\n                                hitHole = true;\n                                break;\n                            }\n                        }\n                    }\n\n                    if (!hitHole)\n                    {\n                        return true;\n                    }\n                }\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Generates intermediate batch data. Either gets converted to drawCalls\n     * or used to convert to batch objects directly by the Graphics object.\n     */\n    updateBatches(): void\n    {\n        if (!this.graphicsData.length)\n        {\n            this.batchable = true;\n\n            return;\n        }\n\n        if (!this.validateBatching())\n        {\n            return;\n        }\n\n        this.cacheDirty = this.dirty;\n\n        const uvs = this.uvs;\n        const graphicsData = this.graphicsData;\n\n        let batchPart: BatchPart = null;\n\n        let currentStyle = null;\n\n        if (this.batches.length > 0)\n        {\n            batchPart = this.batches[this.batches.length - 1];\n            currentStyle = batchPart.style;\n        }\n\n        for (let i = this.shapeIndex; i < graphicsData.length; i++)\n        {\n            this.shapeIndex++;\n\n            const data = graphicsData[i];\n            const fillStyle = data.fillStyle;\n            const lineStyle = data.lineStyle;\n            const command = FILL_COMMANDS[data.type];\n\n            // build out the shapes points..\n            command.build(data);\n\n            if (data.matrix)\n            {\n                this.transformPoints(data.points, data.matrix);\n            }\n\n            if (fillStyle.visible || lineStyle.visible)\n            {\n                this.processHoles(data.holes);\n            }\n\n            for (let j = 0; j < 2; j++)\n            {\n                const style = (j === 0) ? fillStyle : lineStyle;\n\n                if (!style.visible) continue;\n\n                const nextTexture = style.texture.baseTexture;\n                const index = this.indices.length;\n                const attribIndex = this.points.length / 2;\n\n                nextTexture.wrapMode = WRAP_MODES.REPEAT;\n\n                if (j === 0)\n                {\n                    this.processFill(data);\n                }\n                else\n                {\n                    this.processLine(data);\n                }\n\n                const size = (this.points.length / 2) - attribIndex;\n\n                if (size === 0) continue;\n                // close batch if style is different\n                if (batchPart && !this._compareStyles(currentStyle, style))\n                {\n                    batchPart.end(index, attribIndex);\n                    batchPart = null;\n                }\n                // spawn new batch if its first batch or previous was closed\n                if (!batchPart)\n                {\n                    batchPart = BATCH_POOL.pop() || new BatchPart();\n                    batchPart.begin(style, index, attribIndex);\n                    this.batches.push(batchPart);\n                    currentStyle = style;\n                }\n\n                this.addUvs(this.points, uvs, style.texture, attribIndex, size, style.matrix);\n            }\n        }\n\n        const index = this.indices.length;\n        const attrib = this.points.length / 2;\n\n        if (batchPart)\n        {\n            batchPart.end(index, attrib);\n        }\n\n        if (this.batches.length === 0)\n        {\n            // there are no visible styles in GraphicsData\n            // its possible that someone wants Graphics just for the bounds\n            this.batchable = true;\n\n            return;\n        }\n\n        const need32 = attrib > 0xffff;\n\n        // prevent allocation when length is same as buffer\n        if (this.indicesUint16 && this.indices.length === this.indicesUint16.length\n            && need32 === (this.indicesUint16.BYTES_PER_ELEMENT > 2))\n        {\n            this.indicesUint16.set(this.indices);\n        }\n        else\n        {\n            this.indicesUint16 = need32 ? new Uint32Array(this.indices) : new Uint16Array(this.indices);\n        }\n\n        // TODO make this a const..\n        this.batchable = this.isBatchable();\n\n        if (this.batchable)\n        {\n            this.packBatches();\n        }\n        else\n        {\n            this.buildDrawCalls();\n        }\n    }\n\n    /**\n     * Affinity check\n     * @param styleA\n     * @param styleB\n     */\n    protected _compareStyles(styleA: FillStyle | LineStyle, styleB: FillStyle | LineStyle): boolean\n    {\n        if (!styleA || !styleB)\n        {\n            return false;\n        }\n\n        if (styleA.texture.baseTexture !== styleB.texture.baseTexture)\n        {\n            return false;\n        }\n\n        if (styleA.color + styleA.alpha !== styleB.color + styleB.alpha)\n        {\n            return false;\n        }\n\n        if (!!(styleA as LineStyle).native !== !!(styleB as LineStyle).native)\n        {\n            return false;\n        }\n\n        return true;\n    }\n\n    /** Test geometry for batching process. */\n    protected validateBatching(): boolean\n    {\n        if (this.dirty === this.cacheDirty || !this.graphicsData.length)\n        {\n            return false;\n        }\n\n        for (let i = 0, l = this.graphicsData.length; i < l; i++)\n        {\n            const data = this.graphicsData[i];\n            const fill = data.fillStyle;\n            const line = data.lineStyle;\n\n            if (fill && !fill.texture.baseTexture.valid) return false;\n            if (line && !line.texture.baseTexture.valid) return false;\n        }\n\n        return true;\n    }\n\n    /** Offset the indices so that it works with the batcher. */\n    protected packBatches(): void\n    {\n        this.batchDirty++;\n        this.uvsFloat32 = new Float32Array(this.uvs);\n\n        const batches = this.batches;\n\n        for (let i = 0, l = batches.length; i < l; i++)\n        {\n            const batch = batches[i];\n\n            for (let j = 0; j < batch.size; j++)\n            {\n                const index = batch.start + j;\n\n                this.indicesUint16[index] = this.indicesUint16[index] - batch.attribStart;\n            }\n        }\n    }\n\n    /**\n     * Checks to see if this graphics geometry can be batched.\n     * Currently it needs to be small enough and not contain any native lines.\n     */\n    protected isBatchable(): boolean\n    {\n        // prevent heavy mesh batching\n        if (this.points.length > 0xffff * 2)\n        {\n            return false;\n        }\n\n        const batches = this.batches;\n\n        for (let i = 0; i < batches.length; i++)\n        {\n            if ((batches[i].style as LineStyle).native)\n            {\n                return false;\n            }\n        }\n\n        return (this.points.length < GraphicsGeometry.BATCHABLE_SIZE * 2);\n    }\n\n    /** Converts intermediate batches data to drawCalls. */\n    protected buildDrawCalls(): void\n    {\n        let TICK = ++BaseTexture._globalBatch;\n\n        for (let i = 0; i < this.drawCalls.length; i++)\n        {\n            this.drawCalls[i].texArray.clear();\n            DRAW_CALL_POOL.push(this.drawCalls[i]);\n        }\n\n        this.drawCalls.length = 0;\n\n        const colors = this.colors;\n        const textureIds = this.textureIds;\n\n        let currentGroup: BatchDrawCall =  DRAW_CALL_POOL.pop();\n\n        if (!currentGroup)\n        {\n            currentGroup = new BatchDrawCall();\n            currentGroup.texArray = new BatchTextureArray();\n        }\n        currentGroup.texArray.count = 0;\n        currentGroup.start = 0;\n        currentGroup.size = 0;\n        currentGroup.type = DRAW_MODES.TRIANGLES;\n\n        let textureCount = 0;\n        let currentTexture = null;\n        let textureId = 0;\n        let native = false;\n        let drawMode = DRAW_MODES.TRIANGLES;\n\n        let index = 0;\n\n        this.drawCalls.push(currentGroup);\n\n        // TODO - this can be simplified\n        for (let i = 0; i < this.batches.length; i++)\n        {\n            const data = this.batches[i];\n\n            // TODO add some full on MAX_TEXTURE CODE..\n            const MAX_TEXTURES = 8;\n\n            // Forced cast for checking `native` without errors\n            const style = data.style as LineStyle;\n\n            const nextTexture = style.texture.baseTexture;\n\n            if (native !== !!style.native)\n            {\n                native = !!style.native;\n                drawMode = native ? DRAW_MODES.LINES : DRAW_MODES.TRIANGLES;\n\n                // force the batch to break!\n                currentTexture = null;\n                textureCount = MAX_TEXTURES;\n                TICK++;\n            }\n\n            if (currentTexture !== nextTexture)\n            {\n                currentTexture = nextTexture;\n\n                if (nextTexture._batchEnabled !== TICK)\n                {\n                    if (textureCount === MAX_TEXTURES)\n                    {\n                        TICK++;\n\n                        textureCount = 0;\n\n                        if (currentGroup.size > 0)\n                        {\n                            currentGroup = DRAW_CALL_POOL.pop();\n                            if (!currentGroup)\n                            {\n                                currentGroup = new BatchDrawCall();\n                                currentGroup.texArray = new BatchTextureArray();\n                            }\n                            this.drawCalls.push(currentGroup);\n                        }\n\n                        currentGroup.start = index;\n                        currentGroup.size = 0;\n                        currentGroup.texArray.count = 0;\n                        currentGroup.type = drawMode;\n                    }\n\n                    // TODO add this to the render part..\n                    // Hack! Because texture has protected `touched`\n                    nextTexture.touched = 1;// touch;\n\n                    nextTexture._batchEnabled = TICK;\n                    nextTexture._batchLocation = textureCount;\n                    nextTexture.wrapMode = WRAP_MODES.REPEAT;\n\n                    currentGroup.texArray.elements[currentGroup.texArray.count++] = nextTexture;\n                    textureCount++;\n                }\n            }\n\n            currentGroup.size += data.size;\n            index += data.size;\n\n            textureId = nextTexture._batchLocation;\n\n            this.addColors(colors, style.color, style.alpha, data.attribSize, data.attribStart);\n            this.addTextureIds(textureIds, textureId, data.attribSize, data.attribStart);\n        }\n\n        BaseTexture._globalBatch = TICK;\n\n        // upload..\n        // merge for now!\n        this.packAttributes();\n    }\n\n    /** Packs attributes to single buffer. */\n    protected packAttributes(): void\n    {\n        const verts = this.points;\n        const uvs = this.uvs;\n        const colors = this.colors;\n        const textureIds = this.textureIds;\n\n        // verts are 2 positions.. so we * by 3 as there are 6 properties.. then 4 cos its bytes\n        const glPoints = new ArrayBuffer(verts.length * 3 * 4);\n        const f32 = new Float32Array(glPoints);\n        const u32 = new Uint32Array(glPoints);\n\n        let p = 0;\n\n        for (let i = 0; i < verts.length / 2; i++)\n        {\n            f32[p++] = verts[i * 2];\n            f32[p++] = verts[(i * 2) + 1];\n\n            f32[p++] = uvs[i * 2];\n            f32[p++] = uvs[(i * 2) + 1];\n\n            u32[p++] = colors[i];\n\n            f32[p++] = textureIds[i];\n        }\n\n        this._buffer.update(glPoints);\n        this._indexBuffer.update(this.indicesUint16);\n    }\n\n    /**\n     * Process fill part of Graphics.\n     * @param data\n     */\n    protected processFill(data: GraphicsData): void\n    {\n        if (data.holes.length)\n        {\n            buildPoly.triangulate(data, this);\n        }\n        else\n        {\n            const command = FILL_COMMANDS[data.type];\n\n            command.triangulate(data, this);\n        }\n    }\n\n    /**\n     * Process line part of Graphics.\n     * @param data\n     */\n    protected processLine(data: GraphicsData): void\n    {\n        buildLine(data, this);\n\n        for (let i = 0; i < data.holes.length; i++)\n        {\n            buildLine(data.holes[i], this);\n        }\n    }\n\n    /**\n     * Process the holes data.\n     * @param holes\n     */\n    protected processHoles(holes: Array<GraphicsData>): void\n    {\n        for (let i = 0; i < holes.length; i++)\n        {\n            const hole = holes[i];\n            const command = FILL_COMMANDS[hole.type];\n\n            command.build(hole);\n\n            if (hole.matrix)\n            {\n                this.transformPoints(hole.points, hole.matrix);\n            }\n        }\n    }\n\n    /** Update the local bounds of the object. Expensive to use performance-wise. */\n    protected calculateBounds(): void\n    {\n        const bounds = this._bounds;\n\n        bounds.clear();\n        bounds.addVertexData((this.points as any), 0, this.points.length);\n        bounds.pad(this.boundsPadding, this.boundsPadding);\n    }\n\n    /**\n     * Transform points using matrix.\n     * @param points - Points to transform\n     * @param matrix - Transform matrix\n     */\n    protected transformPoints(points: Array<number>, matrix: Matrix): void\n    {\n        for (let i = 0; i < points.length / 2; i++)\n        {\n            const x = points[(i * 2)];\n            const y = points[(i * 2) + 1];\n\n            points[(i * 2)] = (matrix.a * x) + (matrix.c * y) + matrix.tx;\n            points[(i * 2) + 1] = (matrix.b * x) + (matrix.d * y) + matrix.ty;\n        }\n    }\n\n    /**\n     * Add colors.\n     * @param colors - List of colors to add to\n     * @param color - Color to add\n     * @param alpha - Alpha to use\n     * @param size - Number of colors to add\n     * @param offset\n     */\n    protected addColors(\n        colors: Array<number>,\n        color: number,\n        alpha: number,\n        size: number,\n        offset = 0): void\n    {\n        // TODO use the premultiply bits Ivan added\n        const rgb = (color >> 16) + (color & 0xff00) + ((color & 0xff) << 16);\n\n        const rgba = utils.premultiplyTint(rgb, alpha);\n\n        colors.length = Math.max(colors.length, offset + size);\n\n        for (let i = 0; i < size; i++)\n        {\n            colors[offset + i] = rgba;\n        }\n    }\n\n    /**\n     * Add texture id that the shader/fragment wants to use.\n     * @param textureIds\n     * @param id\n     * @param size\n     * @param offset\n     */\n    protected addTextureIds(\n        textureIds: Array<number>,\n        id: number,\n        size: number,\n        offset = 0): void\n    {\n        textureIds.length = Math.max(textureIds.length, offset + size);\n\n        for (let i = 0; i < size; i++)\n        {\n            textureIds[offset + i] = id;\n        }\n    }\n\n    /**\n     * Generates the UVs for a shape.\n     * @param verts - Vertices\n     * @param uvs - UVs\n     * @param texture - Reference to Texture\n     * @param start - Index buffer start index.\n     * @param size - The size/length for index buffer.\n     * @param matrix - Optional transform for all points.\n     */\n    protected addUvs(\n        verts: Array<number>,\n        uvs: Array<number>,\n        texture: Texture,\n        start: number,\n        size: number,\n        matrix: Matrix = null): void\n    {\n        let index = 0;\n        const uvsStart = uvs.length;\n        const frame = texture.frame;\n\n        while (index < size)\n        {\n            let x = verts[(start + index) * 2];\n            let y = verts[((start + index) * 2) + 1];\n\n            if (matrix)\n            {\n                const nx = (matrix.a * x) + (matrix.c * y) + matrix.tx;\n\n                y = (matrix.b * x) + (matrix.d * y) + matrix.ty;\n                x = nx;\n            }\n\n            index++;\n\n            uvs.push(x / frame.width, y / frame.height);\n        }\n\n        const baseTexture = texture.baseTexture;\n\n        if (frame.width < baseTexture.width\n            || frame.height < baseTexture.height)\n        {\n            this.adjustUvs(uvs, texture, uvsStart, size);\n        }\n    }\n\n    /**\n     * Modify uvs array according to position of texture region\n     * Does not work with rotated or trimmed textures\n     * @param uvs - array\n     * @param texture - region\n     * @param start - starting index for uvs\n     * @param size - how many points to adjust\n     */\n    protected adjustUvs(uvs: Array<number>, texture: Texture, start: number, size: number): void\n    {\n        const baseTexture = texture.baseTexture;\n        const eps = 1e-6;\n        const finish = start + (size * 2);\n        const frame = texture.frame;\n        const scaleX = frame.width / baseTexture.width;\n        const scaleY = frame.height / baseTexture.height;\n        let offsetX = frame.x / frame.width;\n        let offsetY = frame.y / frame.height;\n        let minX = Math.floor(uvs[start] + eps);\n        let minY = Math.floor(uvs[start + 1] + eps);\n\n        for (let i = start + 2; i < finish; i += 2)\n        {\n            minX = Math.min(minX, Math.floor(uvs[i] + eps));\n            minY = Math.min(minY, Math.floor(uvs[i + 1] + eps));\n        }\n        offsetX -= minX;\n        offsetY -= minY;\n        for (let i = start; i < finish; i += 2)\n        {\n            uvs[i] = (uvs[i] + offsetX) * scaleX;\n            uvs[i + 1] = (uvs[i + 1] + offsetY) * scaleY;\n        }\n    }\n}\n"],"names":["Point","BatchGeometry","Bounds","DRAW_CALL_POOL","BATCH_POOL","GraphicsData","FILL_COMMANDS","WRAP_MODES","BatchPart","index","BaseTexture","BatchDrawCall","BatchTextureArray","DRAW_MODES","buildPoly","buildLine","utils"],"mappings":"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"}