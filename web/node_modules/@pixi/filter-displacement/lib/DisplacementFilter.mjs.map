{"version":3,"file":"DisplacementFilter.mjs","sources":["../src/DisplacementFilter.ts"],"sourcesContent":["import { Matrix, Point, Filter } from '@pixi/core';\nimport fragment from './displacement.frag';\nimport vertex from './displacement.vert';\n\nimport type { CLEAR_MODES, FilterSystem, RenderTexture, Texture, ISpriteMaskTarget } from '@pixi/core';\n\n/**\n * The DisplacementFilter class uses the pixel values from the specified texture\n * (called the displacement map) to perform a displacement of an object.\n *\n * You can use this filter to apply all manor of crazy warping effects.\n * Currently the `r` property of the texture is used to offset the `x`\n * and the `g` property of the texture is used to offset the `y`.\n *\n * The way it works is it uses the values of the displacement map to look up the\n * correct pixels to output. This means it's not technically moving the original.\n * Instead, it's starting at the output and asking \"which pixel from the original goes here\".\n * For example, if a displacement map pixel has `red = 1` and the filter scale is `20`,\n * this filter will output the pixel approximately 20 pixels to the right of the original.\n * @memberof PIXI.filters\n */\nexport class DisplacementFilter extends Filter\n{\n    public maskSprite: ISpriteMaskTarget;\n    public maskMatrix: Matrix;\n    public scale: Point;\n\n    /**\n     * @param {PIXI.Sprite} sprite - The sprite used for the displacement map. (make sure its added to the scene!)\n     * @param scale - The scale of the displacement\n     */\n    constructor(sprite: ISpriteMaskTarget, scale?: number)\n    {\n        const maskMatrix = new Matrix();\n\n        sprite.renderable = false;\n\n        super(vertex, fragment, {\n            mapSampler: sprite._texture,\n            filterMatrix: maskMatrix,\n            scale: { x: 1, y: 1 },\n            rotation: new Float32Array([1, 0, 0, 1]),\n        });\n\n        this.maskSprite = sprite;\n        this.maskMatrix = maskMatrix;\n\n        if (scale === null || scale === undefined)\n        {\n            scale = 20;\n        }\n\n        /**\n         * scaleX, scaleY for displacements\n         * @member {PIXI.Point}\n         */\n        this.scale = new Point(scale, scale);\n    }\n\n    /**\n     * Applies the filter.\n     * @param filterManager - The manager.\n     * @param input - The input target.\n     * @param output - The output target.\n     * @param clearMode - clearMode.\n     */\n    public apply(\n        filterManager: FilterSystem, input: RenderTexture, output: RenderTexture, clearMode: CLEAR_MODES\n    ): void\n    {\n        // fill maskMatrix with _normalized sprite texture coords_\n        this.uniforms.filterMatrix = filterManager.calculateSpriteMatrix(this.maskMatrix, this.maskSprite);\n        this.uniforms.scale.x = this.scale.x;\n        this.uniforms.scale.y = this.scale.y;\n\n        // Extract rotation from world transform\n        const wt = this.maskSprite.worldTransform;\n        const lenX = Math.sqrt((wt.a * wt.a) + (wt.b * wt.b));\n        const lenY = Math.sqrt((wt.c * wt.c) + (wt.d * wt.d));\n\n        if (lenX !== 0 && lenY !== 0)\n        {\n            this.uniforms.rotation[0] = wt.a / lenX;\n            this.uniforms.rotation[1] = wt.b / lenX;\n            this.uniforms.rotation[2] = wt.c / lenY;\n            this.uniforms.rotation[3] = wt.d / lenY;\n        }\n\n        // draw the filter...\n        filterManager.applyFilter(this, input, output, clearMode);\n    }\n\n    /** The texture used for the displacement map. Must be power of 2 sized texture. */\n    get map(): Texture\n    {\n        return this.uniforms.mapSampler;\n    }\n\n    set map(value: Texture)\n    {\n        this.uniforms.mapSampler = value;\n    }\n}\n"],"names":[],"mappings":";;;;AAqBO,MAAM,2BAA2B,MACxC,CAAA;AAAA,EASI,WAAA,CAAY,QAA2B,KACvC,EAAA;AACI,IAAM,MAAA,UAAA,GAAa,IAAI,MAAO,EAAA,CAAA;AAE9B,IAAA,MAAA,CAAO,UAAa,GAAA,KAAA,CAAA;AAEpB,IAAA,KAAA,CAAM,QAAQ,QAAU,EAAA;AAAA,MACpB,YAAY,MAAO,CAAA,QAAA;AAAA,MACnB,YAAc,EAAA,UAAA;AAAA,MACd,KAAO,EAAA,EAAE,CAAG,EAAA,CAAA,EAAG,GAAG,CAAE,EAAA;AAAA,MACpB,QAAA,EAAU,IAAI,YAAa,CAAA,CAAC,GAAG,CAAG,EAAA,CAAA,EAAG,CAAC,CAAC,CAAA;AAAA,KAC1C,CAAA,CAAA;AAED,IAAA,IAAA,CAAK,UAAa,GAAA,MAAA,CAAA;AAClB,IAAA,IAAA,CAAK,UAAa,GAAA,UAAA,CAAA;AAElB,IAAI,IAAA,KAAA,KAAU,IAAQ,IAAA,KAAA,KAAU,KAChC,CAAA,EAAA;AACI,MAAQ,KAAA,GAAA,EAAA,CAAA;AAAA,KACZ;AAMA,IAAA,IAAA,CAAK,KAAQ,GAAA,IAAI,KAAM,CAAA,KAAA,EAAO,KAAK,CAAA,CAAA;AAAA,GACvC;AAAA,EASA,KAAO,CACH,aAA6B,EAAA,KAAA,EAAsB,QAAuB,SAE9E,EAAA;AAEI,IAAA,IAAA,CAAK,SAAS,YAAe,GAAA,aAAA,CAAc,sBAAsB,IAAK,CAAA,UAAA,EAAY,KAAK,UAAU,CAAA,CAAA;AACjG,IAAA,IAAA,CAAK,QAAS,CAAA,KAAA,CAAM,CAAI,GAAA,IAAA,CAAK,KAAM,CAAA,CAAA,CAAA;AACnC,IAAA,IAAA,CAAK,QAAS,CAAA,KAAA,CAAM,CAAI,GAAA,IAAA,CAAK,KAAM,CAAA,CAAA,CAAA;AAGnC,IAAM,MAAA,EAAA,GAAK,KAAK,UAAW,CAAA,cAAA,CAAA;AAC3B,IAAM,MAAA,IAAA,GAAO,IAAK,CAAA,IAAA,CAAM,EAAG,CAAA,CAAA,GAAI,GAAG,CAAM,GAAA,EAAA,CAAG,CAAI,GAAA,EAAA,CAAG,CAAE,CAAA,CAAA;AACpD,IAAM,MAAA,IAAA,GAAO,IAAK,CAAA,IAAA,CAAM,EAAG,CAAA,CAAA,GAAI,GAAG,CAAM,GAAA,EAAA,CAAG,CAAI,GAAA,EAAA,CAAG,CAAE,CAAA,CAAA;AAEpD,IAAI,IAAA,IAAA,KAAS,CAAK,IAAA,IAAA,KAAS,CAC3B,EAAA;AACI,MAAA,IAAA,CAAK,QAAS,CAAA,QAAA,CAAS,CAAK,CAAA,GAAA,EAAA,CAAG,CAAI,GAAA,IAAA,CAAA;AACnC,MAAA,IAAA,CAAK,QAAS,CAAA,QAAA,CAAS,CAAK,CAAA,GAAA,EAAA,CAAG,CAAI,GAAA,IAAA,CAAA;AACnC,MAAA,IAAA,CAAK,QAAS,CAAA,QAAA,CAAS,CAAK,CAAA,GAAA,EAAA,CAAG,CAAI,GAAA,IAAA,CAAA;AACnC,MAAA,IAAA,CAAK,QAAS,CAAA,QAAA,CAAS,CAAK,CAAA,GAAA,EAAA,CAAG,CAAI,GAAA,IAAA,CAAA;AAAA,KACvC;AAGA,IAAA,aAAA,CAAc,WAAY,CAAA,IAAA,EAAM,KAAO,EAAA,MAAA,EAAQ,SAAS,CAAA,CAAA;AAAA,GAC5D;AAAA,EAGA,IAAI,GACJ,GAAA;AACI,IAAA,OAAO,KAAK,QAAS,CAAA,UAAA,CAAA;AAAA,GACzB;AAAA,EAEA,IAAI,IAAI,KACR,EAAA;AACI,IAAA,IAAA,CAAK,SAAS,UAAa,GAAA,KAAA,CAAA;AAAA,GAC/B;AACJ;;;;"}