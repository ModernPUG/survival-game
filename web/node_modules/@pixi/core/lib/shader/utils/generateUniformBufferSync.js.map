{"version":3,"file":"generateUniformBufferSync.js","sources":["../../../src/shader/utils/generateUniformBufferSync.ts"],"sourcesContent":["import type { Dict } from '@pixi/utils';\nimport { mapSize } from '../utils';\nimport type { IUniformData } from '../Program';\nimport type { UniformGroup } from '../UniformGroup';\nimport { uniformParsers } from './uniformParsers';\nimport type { Renderer } from '../../Renderer';\nimport type { Buffer } from '../../geometry/Buffer';\n\nexport type UniformsSyncCallback = (...args: any[]) => void;\n\nfunction uboUpdate(_ud: any, _uv: any, _renderer: Renderer, _syncData: any, buffer: Buffer): void\n{\n    _renderer.buffer.update(buffer);\n}\n\n// cv = CachedValue\n// v = value\n// ud = uniformData\n// uv = uniformValue\n// l = location\nconst UBO_TO_SINGLE_SETTERS: Dict<string> = {\n    float: `\n        data[offset] = v;\n    `,\n    vec2: `\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n    `,\n    vec3: `\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n        data[offset+2] = v[2];\n\n    `,\n    vec4: `\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n        data[offset+2] = v[2];\n        data[offset+3] = v[3];\n    `,\n    mat2: `\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n\n        data[offset+4] = v[2];\n        data[offset+5] = v[3];\n    `,\n    mat3: `\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n        data[offset+2] = v[2];\n\n        data[offset + 4] = v[3];\n        data[offset + 5] = v[4];\n        data[offset + 6] = v[5];\n\n        data[offset + 8] = v[6];\n        data[offset + 9] = v[7];\n        data[offset + 10] = v[8];\n    `,\n    mat4: `\n        for(var i = 0; i < 16; i++)\n        {\n            data[offset + i] = v[i];\n        }\n    `\n};\n\nconst GLSL_TO_STD40_SIZE: Dict<number> = {\n    float:  4,\n    vec2:   8,\n    vec3:   12,\n    vec4:   16,\n\n    int:      4,\n    ivec2:    8,\n    ivec3:    12,\n    ivec4:    16,\n\n    uint:     4,\n    uvec2:    8,\n    uvec3:    12,\n    uvec4:    16,\n\n    bool:     4,\n    bvec2:    8,\n    bvec3:    12,\n    bvec4:    16,\n\n    mat2:     16 * 2,\n    mat3:     16 * 3,\n    mat4:     16 * 4,\n};\n\ninterface UBOElement\n{\n    data: IUniformData\n    offset: number,\n    dataLen: number,\n    dirty: number\n}\n\n/**\n * logic originally from here: https://github.com/sketchpunk/FunWithWebGL2/blob/master/lesson_022/Shaders.js\n * rewrote it, but this was a great starting point to get a solid understanding of whats going on :)\n * @ignore\n * @param uniformData\n */\nexport function createUBOElements(uniformData: IUniformData[]): {uboElements: UBOElement[], size: number}\n{\n    const uboElements: UBOElement[] = uniformData.map((data: IUniformData) =>\n        ({\n            data,\n            offset: 0,\n            dataLen: 0,\n            dirty: 0\n        }));\n\n    let size = 0;\n    let chunkSize = 0;\n    let offset = 0;\n\n    for (let i = 0; i < uboElements.length; i++)\n    {\n        const uboElement = uboElements[i];\n\n        size = GLSL_TO_STD40_SIZE[uboElement.data.type];\n\n        if (uboElement.data.size > 1)\n        {\n            size = Math.max(size, 16) * uboElement.data.size;\n        }\n\n        uboElement.dataLen = size;\n\n        // add some size offset..\n        // must align to the nearest 16 bytes or internally nearest round size\n\n        if (chunkSize % size !== 0 && chunkSize < 16)\n        {\n            // diff required to line up..\n            const lineUpValue = (chunkSize % size) % 16;\n\n            chunkSize += lineUpValue;\n            offset += lineUpValue;\n        }\n\n        if ((chunkSize + size) > 16)\n        {\n            offset = Math.ceil(offset / 16) * 16;\n            uboElement.offset = offset;\n            offset += size;\n            chunkSize = size;\n        }\n        else\n        {\n            uboElement.offset = offset;\n            chunkSize += size;\n            offset += size;\n        }\n    }\n\n    offset = Math.ceil(offset / 16) * 16;\n\n    return { uboElements, size: offset };\n}\n\nexport function getUBOData(uniforms: Dict<any>, uniformData: Dict<any>): any[]\n{\n    const usedUniformDatas = [];\n\n    // build..\n    for (const i in uniforms)\n    {\n        if (uniformData[i])\n        {\n            usedUniformDatas.push(uniformData[i]);\n        }\n    }\n\n    // sort them out by index!\n    usedUniformDatas.sort((a, b) => a.index - b.index);\n\n    return usedUniformDatas;\n}\n\nexport function generateUniformBufferSync(\n    group: UniformGroup,\n    uniformData: Dict<any>\n): {size: number, syncFunc: UniformsSyncCallback}\n{\n    if (!group.autoManage)\n    {\n        // if the group is nott automatically managed, we don't need to generate a special function for it...\n        return { size: 0, syncFunc: uboUpdate };\n    }\n\n    const usedUniformDatas = getUBOData(group.uniforms, uniformData);\n\n    const { uboElements, size } = createUBOElements(usedUniformDatas);\n\n    const funcFragments = [`\n    var v = null;\n    var v2 = null;\n    var cv = null;\n    var t = 0;\n    var gl = renderer.gl\n    var index = 0;\n    var data = buffer.data;\n    `];\n\n    for (let i = 0; i < uboElements.length; i++)\n    {\n        const uboElement = uboElements[i];\n        const uniform = group.uniforms[uboElement.data.name];\n\n        const name = uboElement.data.name;\n\n        let parsed = false;\n\n        for (let j = 0; j < uniformParsers.length; j++)\n        {\n            const uniformParser = uniformParsers[j];\n\n            if (uniformParser.codeUbo && uniformParser.test(uboElement.data, uniform))\n            {\n                funcFragments.push(\n                    `offset = ${uboElement.offset / 4};`,\n                    uniformParsers[j].codeUbo(uboElement.data.name, uniform));\n                parsed = true;\n\n                break;\n            }\n        }\n\n        if (!parsed)\n        {\n            if (uboElement.data.size > 1)\n            {\n                const size =  mapSize(uboElement.data.type);\n                const rowSize = Math.max(GLSL_TO_STD40_SIZE[uboElement.data.type] / 16, 1);\n                const elementSize = size / rowSize;\n                const remainder = (4 - (elementSize % 4)) % 4;\n\n                funcFragments.push(`\n                cv = ud.${name}.value;\n                v = uv.${name};\n                offset = ${uboElement.offset / 4};\n\n                t = 0;\n\n                for(var i=0; i < ${uboElement.data.size * rowSize}; i++)\n                {\n                    for(var j = 0; j < ${elementSize}; j++)\n                    {\n                        data[offset++] = v[t++];\n                    }\n                    offset += ${remainder};\n                }\n\n                `);\n            }\n            else\n            {\n                const template = UBO_TO_SINGLE_SETTERS[uboElement.data.type];\n\n                funcFragments.push(`\n                cv = ud.${name}.value;\n                v = uv.${name};\n                offset = ${uboElement.offset / 4};\n                ${template};\n                `);\n            }\n        }\n    }\n\n    funcFragments.push(`\n       renderer.buffer.update(buffer);\n    `);\n\n    return {\n        size,\n        // eslint-disable-next-line no-new-func\n        syncFunc: new Function(\n            'ud',\n            'uv',\n            'renderer',\n            'syncData',\n            'buffer',\n            funcFragments.join('\\n')\n        ) as UniformsSyncCallback\n    };\n}\n"],"names":["uniformParsers","mapSize"],"mappings":"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"}