{"version":3,"file":"Buffer.mjs","sources":["../../src/geometry/Buffer.ts"],"sourcesContent":["import { BUFFER_TYPE } from '@pixi/constants';\nimport { Runner } from '@pixi/runner';\nimport type { GLBuffer } from './GLBuffer';\n\nlet UID = 0;\n/* eslint-disable max-len */\n\n/**\n * Marks places in PixiJS where you can pass Float32Array, UInt32Array, any typed arrays, and ArrayBuffer\n *\n * Same as ArrayBuffer in typescript lib, defined here just for documentation\n */\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\nexport interface IArrayBuffer extends ArrayBuffer\n{\n}\n\n/**\n * PixiJS classes use this type instead of ArrayBuffer and typed arrays\n * to support expressions like `geometry.buffers[0].data[0] = position.x`.\n *\n * Gives access to indexing and `length` field\n * - @popelyshev: If data is actually ArrayBuffer and throws Exception on indexing - its user problem :)\n */\nexport interface ITypedArray extends IArrayBuffer\n{\n    readonly length: number;\n    [index: number]: number;\n    readonly BYTES_PER_ELEMENT: number;\n}\n\n/**\n * A wrapper for data so that it can be used and uploaded by WebGL\n * @memberof PIXI\n */\nexport class Buffer\n{\n    /**\n     * The data in the buffer, as a typed array\n     * @type {PIXI.IArrayBuffer}\n     */\n    public data: ITypedArray;\n\n    /**\n     * The type of buffer this is, one of:\n     * + ELEMENT_ARRAY_BUFFER - used as an index buffer\n     * + ARRAY_BUFFER - used as an attribute buffer\n     * + UNIFORM_BUFFER - used as a uniform buffer (if available)\n     */\n    public type: BUFFER_TYPE;\n\n    public static: boolean;\n    public id: number;\n    disposeRunner: Runner;\n\n    /**\n     * A map of renderer IDs to webgl buffer\n     * @private\n     * @type {Object<number, GLBuffer>}\n     */\n    _glBuffers: {[key: number]: GLBuffer};\n    _updateID: number;\n\n    /**\n     * @param {PIXI.IArrayBuffer} data - the data to store in the buffer.\n     * @param _static - `true` for static buffer\n     * @param index - `true` for index buffer\n     */\n    constructor(data?: IArrayBuffer, _static = true, index = false)\n    {\n        this.data = (data || new Float32Array(1)) as ITypedArray;\n\n        this._glBuffers = {};\n        this._updateID = 0;\n\n        this.index = index;\n        this.static = _static;\n        this.id = UID++;\n\n        this.disposeRunner = new Runner('disposeBuffer');\n    }\n\n    // TODO could explore flagging only a partial upload?\n    /**\n     * Flags this buffer as requiring an upload to the GPU.\n     * @param {PIXI.IArrayBuffer|number[]} [data] - the data to update in the buffer.\n     */\n    update(data?: IArrayBuffer | Array<number>): void\n    {\n        if (data instanceof Array)\n        {\n            data = new Float32Array(data);\n        }\n        this.data = (data as ITypedArray) || this.data;\n        this._updateID++;\n    }\n\n    /** Disposes WebGL resources that are connected to this geometry. */\n    dispose(): void\n    {\n        this.disposeRunner.emit(this, false);\n    }\n\n    /** Destroys the buffer. */\n    destroy(): void\n    {\n        this.dispose();\n\n        this.data = null;\n    }\n\n    /**\n     * Flags whether this is an index buffer.\n     *\n     * Index buffers are of type `ELEMENT_ARRAY_BUFFER`. Note that setting this property to false will make\n     * the buffer of type `ARRAY_BUFFER`.\n     *\n     * For backwards compatibility.\n     */\n    set index(value: boolean)\n    {\n        this.type = value ? BUFFER_TYPE.ELEMENT_ARRAY_BUFFER : BUFFER_TYPE.ARRAY_BUFFER;\n    }\n\n    get index(): boolean\n    {\n        return this.type === BUFFER_TYPE.ELEMENT_ARRAY_BUFFER;\n    }\n\n    /**\n     * Helper function that creates a buffer based on an array or TypedArray\n     * @param {ArrayBufferView | number[]} data - the TypedArray that the buffer will store. If this is a regular Array it will be converted to a Float32Array.\n     * @returns - A new Buffer based on the data provided.\n     */\n    static from(data: IArrayBuffer | number[]): Buffer\n    {\n        if (data instanceof Array)\n        {\n            data = new Float32Array(data);\n        }\n\n        return new Buffer(data);\n    }\n}\n"],"names":[],"mappings":";;;AAIA,IAAI,GAAM,GAAA,CAAA,CAAA;AA+BH,MAAM,MACb,CAAA;AAAA,EAgCI,WAAY,CAAA,IAAA,EAAqB,OAAU,GAAA,IAAA,EAAM,QAAQ,KACzD,EAAA;AACI,IAAA,IAAA,CAAK,IAAQ,GAAA,IAAA,IAAQ,IAAI,YAAA,CAAa,CAAC,CAAA,CAAA;AAEvC,IAAA,IAAA,CAAK,aAAa,EAAC,CAAA;AACnB,IAAA,IAAA,CAAK,SAAY,GAAA,CAAA,CAAA;AAEjB,IAAA,IAAA,CAAK,KAAQ,GAAA,KAAA,CAAA;AACb,IAAA,IAAA,CAAK,MAAS,GAAA,OAAA,CAAA;AACd,IAAA,IAAA,CAAK,EAAK,GAAA,GAAA,EAAA,CAAA;AAEV,IAAK,IAAA,CAAA,aAAA,GAAgB,IAAI,MAAA,CAAO,eAAe,CAAA,CAAA;AAAA,GACnD;AAAA,EAOA,OAAO,IACP,EAAA;AACI,IAAA,IAAI,gBAAgB,KACpB,EAAA;AACI,MAAO,IAAA,GAAA,IAAI,aAAa,IAAI,CAAA,CAAA;AAAA,KAChC;AACA,IAAK,IAAA,CAAA,IAAA,GAAQ,QAAwB,IAAK,CAAA,IAAA,CAAA;AAC1C,IAAK,IAAA,CAAA,SAAA,EAAA,CAAA;AAAA,GACT;AAAA,EAGA,OACA,GAAA;AACI,IAAK,IAAA,CAAA,aAAA,CAAc,IAAK,CAAA,IAAA,EAAM,KAAK,CAAA,CAAA;AAAA,GACvC;AAAA,EAGA,OACA,GAAA;AACI,IAAA,IAAA,CAAK,OAAQ,EAAA,CAAA;AAEb,IAAA,IAAA,CAAK,IAAO,GAAA,IAAA,CAAA;AAAA,GAChB;AAAA,EAUA,IAAI,MAAM,KACV,EAAA;AACI,IAAA,IAAA,CAAK,IAAO,GAAA,KAAA,GAAQ,WAAY,CAAA,oBAAA,GAAuB,WAAY,CAAA,YAAA,CAAA;AAAA,GACvE;AAAA,EAEA,IAAI,KACJ,GAAA;AACI,IAAO,OAAA,IAAA,CAAK,SAAS,WAAY,CAAA,oBAAA,CAAA;AAAA,GACrC;AAAA,EAOA,OAAO,KAAK,IACZ,EAAA;AACI,IAAA,IAAI,gBAAgB,KACpB,EAAA;AACI,MAAO,IAAA,GAAA,IAAI,aAAa,IAAI,CAAA,CAAA;AAAA,KAChC;AAEA,IAAO,OAAA,IAAI,OAAO,IAAI,CAAA,CAAA;AAAA,GAC1B;AACJ;;;;"}