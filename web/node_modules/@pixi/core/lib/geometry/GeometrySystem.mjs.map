{"version":3,"file":"GeometrySystem.mjs","sources":["../../src/geometry/GeometrySystem.ts"],"sourcesContent":["import type { GLBuffer } from './GLBuffer';\nimport { BUFFER_TYPE, ENV } from '@pixi/constants';\nimport { settings } from '../settings';\n\nimport type { ISystem } from '../system/ISystem';\nimport type { DRAW_MODES } from '@pixi/constants';\nimport type { Renderer } from '../Renderer';\nimport type { Geometry } from './Geometry';\nimport type { Shader } from '../shader/Shader';\nimport type { Program } from '../shader/Program';\nimport type { Dict } from '@pixi/utils';\nimport type { IRenderingContext } from '../IRenderer';\nimport type { ExtensionMetadata } from '@pixi/extensions';\nimport { extensions, ExtensionType } from '@pixi/extensions';\n\nconst byteSizeMap: {[key: number]: number} = { 5126: 4, 5123: 2, 5121: 1 };\n\n/**\n * System plugin to the renderer to manage geometry.\n * @memberof PIXI\n */\nexport class GeometrySystem implements ISystem\n{\n    /** @ignore */\n    static extension: ExtensionMetadata = {\n        type: ExtensionType.RendererSystem,\n        name: 'geometry',\n    };\n\n    /**\n     * `true` if we has `*_vertex_array_object` extension.\n     * @readonly\n     */\n    public hasVao: boolean;\n\n    /**\n     * `true` if has `ANGLE_instanced_arrays` extension.\n     * @readonly\n     */\n    public hasInstance: boolean;\n\n    /**\n     * `true` if support `gl.UNSIGNED_INT` in `gl.drawElements` or `gl.drawElementsInstanced`.\n     * @readonly\n     */\n    public canUseUInt32ElementIndex: boolean;\n\n    protected CONTEXT_UID: number;\n    protected gl: IRenderingContext;\n    protected _activeGeometry: Geometry;\n    protected _activeVao: WebGLVertexArrayObject;\n    protected _boundBuffer: GLBuffer;\n\n    /** Cache for all geometries by id, used in case renderer gets destroyed or for profiling. */\n    readonly managedGeometries: {[key: number]: Geometry};\n\n    /** Renderer that owns this {@link GeometrySystem}. */\n    private renderer: Renderer;\n\n    /** @param renderer - The renderer this System works for. */\n    constructor(renderer: Renderer)\n    {\n        this.renderer = renderer;\n        this._activeGeometry = null;\n        this._activeVao = null;\n\n        this.hasVao = true;\n        this.hasInstance = true;\n        this.canUseUInt32ElementIndex = false;\n        this.managedGeometries = {};\n    }\n\n    /** Sets up the renderer context and necessary buffers. */\n    protected contextChange(): void\n    {\n        this.disposeAll(true);\n\n        const gl = this.gl = this.renderer.gl;\n        const context = this.renderer.context;\n\n        this.CONTEXT_UID = this.renderer.CONTEXT_UID;\n\n        // webgl2\n        if (context.webGLVersion !== 2)\n        {\n            // webgl 1!\n            let nativeVaoExtension = this.renderer.context.extensions.vertexArrayObject;\n\n            if (settings.PREFER_ENV === ENV.WEBGL_LEGACY)\n            {\n                nativeVaoExtension = null;\n            }\n\n            if (nativeVaoExtension)\n            {\n                gl.createVertexArray = (): WebGLVertexArrayObject =>\n                    nativeVaoExtension.createVertexArrayOES();\n\n                gl.bindVertexArray = (vao): void =>\n                    nativeVaoExtension.bindVertexArrayOES(vao);\n\n                gl.deleteVertexArray = (vao): void =>\n                    nativeVaoExtension.deleteVertexArrayOES(vao);\n            }\n            else\n            {\n                this.hasVao = false;\n                gl.createVertexArray = (): WebGLVertexArrayObject =>\n                    null;\n\n                gl.bindVertexArray = (): void =>\n                    null;\n\n                gl.deleteVertexArray = (): void =>\n                    null;\n            }\n        }\n\n        if (context.webGLVersion !== 2)\n        {\n            const instanceExt = gl.getExtension('ANGLE_instanced_arrays');\n\n            if (instanceExt)\n            {\n                gl.vertexAttribDivisor = (a, b): void =>\n                    instanceExt.vertexAttribDivisorANGLE(a, b);\n\n                gl.drawElementsInstanced = (a, b, c, d, e): void =>\n                    instanceExt.drawElementsInstancedANGLE(a, b, c, d, e);\n\n                gl.drawArraysInstanced = (a, b, c, d): void =>\n                    instanceExt.drawArraysInstancedANGLE(a, b, c, d);\n            }\n            else\n            {\n                this.hasInstance = false;\n            }\n        }\n\n        this.canUseUInt32ElementIndex = context.webGLVersion === 2 || !!context.extensions.uint32ElementIndex;\n    }\n\n    /**\n     * Binds geometry so that is can be drawn. Creating a Vao if required\n     * @param geometry - Instance of geometry to bind.\n     * @param shader - Instance of shader to use vao for.\n     */\n    bind(geometry?: Geometry, shader?: Shader): void\n    {\n        shader = shader || this.renderer.shader.shader;\n\n        const { gl } = this;\n\n        // not sure the best way to address this..\n        // currently different shaders require different VAOs for the same geometry\n        // Still mulling over the best way to solve this one..\n        // will likely need to modify the shader attribute locations at run time!\n        let vaos = geometry.glVertexArrayObjects[this.CONTEXT_UID];\n        let incRefCount = false;\n\n        if (!vaos)\n        {\n            this.managedGeometries[geometry.id] = geometry;\n            geometry.disposeRunner.add(this);\n            geometry.glVertexArrayObjects[this.CONTEXT_UID] = vaos = {};\n            incRefCount = true;\n        }\n\n        const vao = vaos[shader.program.id] || this.initGeometryVao(geometry, shader, incRefCount);\n\n        this._activeGeometry = geometry;\n\n        if (this._activeVao !== vao)\n        {\n            this._activeVao = vao;\n\n            if (this.hasVao)\n            {\n                gl.bindVertexArray(vao);\n            }\n            else\n            {\n                this.activateVao(geometry, shader.program);\n            }\n        }\n\n        // TODO - optimise later!\n        // don't need to loop through if nothing changed!\n        // maybe look to add an 'autoupdate' to geometry?\n        this.updateBuffers();\n    }\n\n    /** Reset and unbind any active VAO and geometry. */\n    reset(): void\n    {\n        this.unbind();\n    }\n\n    /** Update buffers of the currently bound geometry. */\n    updateBuffers(): void\n    {\n        const geometry = this._activeGeometry;\n\n        const bufferSystem = this.renderer.buffer;\n\n        for (let i = 0; i < geometry.buffers.length; i++)\n        {\n            const buffer = geometry.buffers[i];\n\n            bufferSystem.update(buffer);\n        }\n    }\n\n    /**\n     * Check compatibility between a geometry and a program\n     * @param geometry - Geometry instance.\n     * @param program - Program instance.\n     */\n    protected checkCompatibility(geometry: Geometry, program: Program): void\n    {\n        // geometry must have at least all the attributes that the shader requires.\n        const geometryAttributes = geometry.attributes;\n        const shaderAttributes = program.attributeData;\n\n        for (const j in shaderAttributes)\n        {\n            if (!geometryAttributes[j])\n            {\n                throw new Error(`shader and geometry incompatible, geometry missing the \"${j}\" attribute`);\n            }\n        }\n    }\n\n    /**\n     * Takes a geometry and program and generates a unique signature for them.\n     * @param geometry - To get signature from.\n     * @param program - To test geometry against.\n     * @returns - Unique signature of the geometry and program\n     */\n    protected getSignature(geometry: Geometry, program: Program): string\n    {\n        const attribs = geometry.attributes;\n        const shaderAttributes = program.attributeData;\n\n        const strings = ['g', geometry.id];\n\n        for (const i in attribs)\n        {\n            if (shaderAttributes[i])\n            {\n                strings.push(i, shaderAttributes[i].location);\n            }\n        }\n\n        return strings.join('-');\n    }\n\n    /**\n     * Creates or gets Vao with the same structure as the geometry and stores it on the geometry.\n     * If vao is created, it is bound automatically. We use a shader to infer what and how to set up the\n     * attribute locations.\n     * @param geometry - Instance of geometry to to generate Vao for.\n     * @param shader - Instance of the shader.\n     * @param incRefCount - Increment refCount of all geometry buffers.\n     */\n    protected initGeometryVao(geometry: Geometry, shader: Shader, incRefCount = true): WebGLVertexArrayObject\n    {\n        const gl = this.gl;\n        const CONTEXT_UID = this.CONTEXT_UID;\n        const bufferSystem = this.renderer.buffer;\n        const program = shader.program;\n\n        if (!program.glPrograms[CONTEXT_UID])\n        {\n            this.renderer.shader.generateProgram(shader);\n        }\n\n        this.checkCompatibility(geometry, program);\n\n        const signature = this.getSignature(geometry, program);\n\n        const vaoObjectHash = geometry.glVertexArrayObjects[this.CONTEXT_UID];\n\n        let vao = vaoObjectHash[signature];\n\n        if (vao)\n        {\n            // this will give us easy access to the vao\n            vaoObjectHash[program.id] = vao;\n\n            return vao;\n        }\n\n        const buffers = geometry.buffers;\n        const attributes = geometry.attributes;\n        const tempStride: Dict<number> = {};\n        const tempStart: Dict<number> = {};\n\n        for (const j in buffers)\n        {\n            tempStride[j] = 0;\n            tempStart[j] = 0;\n        }\n\n        for (const j in attributes)\n        {\n            if (!attributes[j].size && program.attributeData[j])\n            {\n                attributes[j].size = program.attributeData[j].size;\n            }\n            else if (!attributes[j].size)\n            {\n                console.warn(`PIXI Geometry attribute '${j}' size cannot be determined (likely the bound shader does not have the attribute)`);  // eslint-disable-line\n            }\n\n            tempStride[attributes[j].buffer] += attributes[j].size * byteSizeMap[attributes[j].type];\n        }\n\n        for (const j in attributes)\n        {\n            const attribute = attributes[j];\n            const attribSize = attribute.size;\n\n            if (attribute.stride === undefined)\n            {\n                if (tempStride[attribute.buffer] === attribSize * byteSizeMap[attribute.type])\n                {\n                    attribute.stride = 0;\n                }\n                else\n                {\n                    attribute.stride = tempStride[attribute.buffer];\n                }\n            }\n\n            if (attribute.start === undefined)\n            {\n                attribute.start = tempStart[attribute.buffer];\n\n                tempStart[attribute.buffer] += attribSize * byteSizeMap[attribute.type];\n            }\n        }\n\n        // @TODO: We don't know if VAO is supported.\n        vao = gl.createVertexArray();\n\n        gl.bindVertexArray(vao);\n\n        // first update - and create the buffers!\n        // only create a gl buffer if it actually gets\n        for (let i = 0; i < buffers.length; i++)\n        {\n            const buffer = buffers[i];\n\n            bufferSystem.bind(buffer);\n\n            if (incRefCount)\n            {\n                buffer._glBuffers[CONTEXT_UID].refCount++;\n            }\n        }\n\n        // TODO - maybe make this a data object?\n        // lets wait to see if we need to first!\n\n        this.activateVao(geometry, program);\n\n        // add it to the cache!\n        vaoObjectHash[program.id] = vao;\n        vaoObjectHash[signature] = vao;\n\n        gl.bindVertexArray(null);\n        bufferSystem.unbind(BUFFER_TYPE.ARRAY_BUFFER);\n\n        return vao;\n    }\n\n    /**\n     * Disposes geometry.\n     * @param geometry - Geometry with buffers. Only VAO will be disposed\n     * @param [contextLost=false] - If context was lost, we suppress deleteVertexArray\n     */\n    disposeGeometry(geometry: Geometry, contextLost?: boolean): void\n    {\n        if (!this.managedGeometries[geometry.id])\n        {\n            return;\n        }\n\n        delete this.managedGeometries[geometry.id];\n\n        const vaos = geometry.glVertexArrayObjects[this.CONTEXT_UID];\n        const gl = this.gl;\n        const buffers = geometry.buffers;\n        const bufferSystem = this.renderer?.buffer;\n\n        geometry.disposeRunner.remove(this);\n\n        if (!vaos)\n        {\n            return;\n        }\n\n        // bufferSystem may have already been destroyed..\n        // if this is the case, there is no need to destroy the geometry buffers...\n        // they already have been!\n        if (bufferSystem)\n        {\n            for (let i = 0; i < buffers.length; i++)\n            {\n                const buf = buffers[i]._glBuffers[this.CONTEXT_UID];\n\n                // my be null as context may have changed right before the dispose is called\n                if (buf)\n                {\n                    buf.refCount--;\n                    if (buf.refCount === 0 && !contextLost)\n                    {\n                        bufferSystem.dispose(buffers[i], contextLost);\n                    }\n                }\n            }\n        }\n\n        if (!contextLost)\n        {\n            for (const vaoId in vaos)\n            {\n                // delete only signatures, everything else are copies\n                if (vaoId[0] === 'g')\n                {\n                    const vao = vaos[vaoId];\n\n                    if (this._activeVao === vao)\n                    {\n                        this.unbind();\n                    }\n                    gl.deleteVertexArray(vao);\n                }\n            }\n        }\n\n        delete geometry.glVertexArrayObjects[this.CONTEXT_UID];\n    }\n\n    /**\n     * Dispose all WebGL resources of all managed geometries.\n     * @param [contextLost=false] - If context was lost, we suppress `gl.delete` calls\n     */\n    disposeAll(contextLost?: boolean): void\n    {\n        const all: Array<any> = Object.keys(this.managedGeometries);\n\n        for (let i = 0; i < all.length; i++)\n        {\n            this.disposeGeometry(this.managedGeometries[all[i]], contextLost);\n        }\n    }\n\n    /**\n     * Activate vertex array object.\n     * @param geometry - Geometry instance.\n     * @param program - Shader program instance.\n     */\n    protected activateVao(geometry: Geometry, program: Program): void\n    {\n        const gl = this.gl;\n        const CONTEXT_UID = this.CONTEXT_UID;\n        const bufferSystem = this.renderer.buffer;\n        const buffers = geometry.buffers;\n        const attributes = geometry.attributes;\n\n        if (geometry.indexBuffer)\n        {\n            // first update the index buffer if we have one..\n            bufferSystem.bind(geometry.indexBuffer);\n        }\n\n        let lastBuffer = null;\n\n        // add a new one!\n        for (const j in attributes)\n        {\n            const attribute = attributes[j];\n            const buffer = buffers[attribute.buffer];\n            const glBuffer = buffer._glBuffers[CONTEXT_UID];\n\n            if (program.attributeData[j])\n            {\n                if (lastBuffer !== glBuffer)\n                {\n                    bufferSystem.bind(buffer);\n\n                    lastBuffer = glBuffer;\n                }\n\n                const location = program.attributeData[j].location;\n\n                // TODO introduce state again\n                // we can optimise this for older devices that have no VAOs\n                gl.enableVertexAttribArray(location);\n\n                gl.vertexAttribPointer(location,\n                    attribute.size,\n                    attribute.type || gl.FLOAT,\n                    attribute.normalized,\n                    attribute.stride,\n                    attribute.start);\n\n                if (attribute.instance)\n                {\n                    // TODO calculate instance count based of this...\n                    if (this.hasInstance)\n                    {\n                        gl.vertexAttribDivisor(location, 1);\n                    }\n                    else\n                    {\n                        throw new Error('geometry error, GPU Instancing is not supported on this device');\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Draws the currently bound geometry.\n     * @param type - The type primitive to render.\n     * @param size - The number of elements to be rendered. If not specified, all vertices after the\n     *  starting vertex will be drawn.\n     * @param start - The starting vertex in the geometry to start drawing from. If not specified,\n     *  drawing will start from the first vertex.\n     * @param instanceCount - The number of instances of the set of elements to execute. If not specified,\n     *  all instances will be drawn.\n     */\n    draw(type: DRAW_MODES, size?: number, start?: number, instanceCount?: number): this\n    {\n        const { gl } = this;\n        const geometry = this._activeGeometry;\n\n        // TODO.. this should not change so maybe cache the function?\n\n        if (geometry.indexBuffer)\n        {\n            const byteSize = geometry.indexBuffer.data.BYTES_PER_ELEMENT;\n            const glType = byteSize === 2 ? gl.UNSIGNED_SHORT : gl.UNSIGNED_INT;\n\n            if (byteSize === 2 || (byteSize === 4 && this.canUseUInt32ElementIndex))\n            {\n                if (geometry.instanced)\n                {\n                    /* eslint-disable max-len */\n                    gl.drawElementsInstanced(type, size || geometry.indexBuffer.data.length, glType, (start || 0) * byteSize, instanceCount || 1);\n                    /* eslint-enable max-len */\n                }\n                else\n                {\n                    /* eslint-disable max-len */\n                    gl.drawElements(type, size || geometry.indexBuffer.data.length, glType, (start || 0) * byteSize);\n                    /* eslint-enable max-len */\n                }\n            }\n            else\n            {\n                console.warn('unsupported index buffer type: uint32');\n            }\n        }\n        else if (geometry.instanced)\n        {\n            // TODO need a better way to calculate size..\n            gl.drawArraysInstanced(type, start, size || geometry.getSize(), instanceCount || 1);\n        }\n        else\n        {\n            gl.drawArrays(type, start, size || geometry.getSize());\n        }\n\n        return this;\n    }\n\n    /** Unbind/reset everything. */\n    protected unbind(): void\n    {\n        this.gl.bindVertexArray(null);\n        this._activeVao = null;\n        this._activeGeometry = null;\n    }\n\n    destroy(): void\n    {\n        this.renderer = null;\n    }\n}\n\nextensions.add(GeometrySystem);\n"],"names":[],"mappings":"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"}