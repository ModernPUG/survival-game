{"version":3,"file":"BaseTexture.js","sources":["../../src/textures/BaseTexture.ts"],"sourcesContent":["import { BaseTextureCache, EventEmitter, isPow2, TextureCache, uid } from '@pixi/utils';\nimport { FORMATS, SCALE_MODES, TARGETS, TYPES, ALPHA_MODES } from '@pixi/constants';\nimport { Resource } from './resources/Resource';\nimport { BufferResource } from './resources/BufferResource';\nimport { autoDetectResource } from './resources/autoDetectResource';\nimport { settings } from '@pixi/settings';\n\nimport type { MSAA_QUALITY, MIPMAP_MODES, WRAP_MODES } from '@pixi/constants';\nimport type { ICanvas } from '@pixi/settings';\nimport type { IAutoDetectOptions } from './resources/autoDetectResource';\nimport type { GLTexture } from './GLTexture';\n\nconst defaultBufferOptions = {\n    scaleMode: SCALE_MODES.NEAREST,\n    format: FORMATS.RGBA,\n    alphaMode: ALPHA_MODES.NPM,\n};\n\nexport type ImageSource = HTMLImageElement | HTMLVideoElement | ImageBitmap | ICanvas;\n\nexport interface IBaseTextureOptions<RO = any>\n{\n    alphaMode?: ALPHA_MODES;\n    mipmap?: MIPMAP_MODES;\n    anisotropicLevel?: number;\n    scaleMode?: SCALE_MODES;\n    width?: number;\n    height?: number;\n    wrapMode?: WRAP_MODES;\n    format?: FORMATS;\n    type?: TYPES;\n    target?: TARGETS;\n    resolution?: number;\n    multisample?: MSAA_QUALITY;\n    resourceOptions?: RO;\n    pixiIdPrefix?: string;\n}\n\nexport interface BaseTexture extends GlobalMixins.BaseTexture, EventEmitter {}\n\n/**\n * A Texture stores the information that represents an image.\n * All textures have a base texture, which contains information about the source.\n * Therefore you can have many textures all using a single BaseTexture\n * @memberof PIXI\n * @typeParam R - The BaseTexture's Resource type.\n * @typeParam RO - The options for constructing resource.\n */\nexport class BaseTexture<R extends Resource = Resource, RO = IAutoDetectOptions> extends EventEmitter\n{\n    /**\n     * The width of the base texture set when the image has loaded\n     * @readonly\n     */\n    public width: number;\n\n    /**\n     * The height of the base texture set when the image has loaded\n     * @readonly\n     */\n    public height: number;\n\n    /**\n     * The resolution / device pixel ratio of the texture\n     * @readonly\n     * @default PIXI.settings.RESOLUTION\n     */\n    public resolution: number;\n\n    /**\n     * How to treat premultiplied alpha, see {@link PIXI.ALPHA_MODES}.\n     * @member {PIXI.ALPHA_MODES}\n     * @default PIXI.ALPHA_MODES.UNPACK\n     */\n    public alphaMode?: ALPHA_MODES;\n\n    /**\n     * Anisotropic filtering level of texture\n     * @member {number}\n     * @default PIXI.settings.ANISOTROPIC_LEVEL\n     */\n    public anisotropicLevel?: number;\n\n    /**\n     * The pixel format of the texture\n     * @default PIXI.FORMATS.RGBA\n     */\n    public format?: FORMATS;\n\n    /**\n     * The type of resource data\n     * @default PIXI.TYPES.UNSIGNED_BYTE\n     */\n    public type?: TYPES;\n\n    /**\n     * The target type\n     * @default PIXI.TARGETS.TEXTURE_2D\n     */\n    public target?: TARGETS;\n\n    /**\n     * Global unique identifier for this BaseTexture\n     * @protected\n     */\n    public readonly uid: number;\n\n    /**\n     * Used by automatic texture Garbage Collection, stores last GC tick when it was bound\n     * @protected\n     */\n    touched: number;\n\n    /**\n     * Whether or not the texture is a power of two, try to use power of two textures as much\n     * as you can\n     * @readonly\n     * @default false\n     */\n    isPowerOfTwo: boolean;\n\n    /**\n     * The map of render context textures where this is bound\n     * @private\n     */\n    _glTextures: { [key: number]: GLTexture };\n\n    /**\n     * Used by TextureSystem to only update texture to the GPU when needed.\n     * Please call `update()` to increment it.\n     * @readonly\n     */\n    dirtyId: number;\n\n    /**\n     * Used by TextureSystem to only update texture style when needed.\n     * @protected\n     */\n    dirtyStyleId: number;\n\n    /**\n     * Currently default cache ID.\n     * @member {string}\n     */\n    public cacheId: string;\n\n    /**\n     * Generally speaking means when resource is loaded.\n     * @readonly\n     * @member {boolean}\n     */\n    public valid: boolean;\n\n    /**\n     * The collection of alternative cache ids, since some BaseTextures\n     * can have more than one ID, short name and longer full URL\n     * @member {Array<string>}\n     * @readonly\n     */\n    public textureCacheIds: Array<string>;\n\n    /**\n     * Flag if BaseTexture has been destroyed.\n     * @member {boolean}\n     * @readonly\n     */\n    public destroyed: boolean;\n\n    /**\n     * The resource used by this BaseTexture, there can only\n     * be one resource per BaseTexture, but textures can share\n     * resources.\n     * @member {PIXI.Resource}\n     * @readonly\n     */\n    public resource: R;\n\n    /**\n     * Number of the texture batch, used by multi-texture renderers\n     * @member {number}\n     */\n    _batchEnabled: number;\n\n    /**\n     * Location inside texture batch, used by multi-texture renderers\n     * @member {number}\n     */\n    _batchLocation: number;\n\n    /**\n     * Whether its a part of another texture, handled by ArrayResource or CubeResource\n     * @member {PIXI.BaseTexture}\n     */\n    parentTextureArray: BaseTexture;\n\n    private _mipmap?: MIPMAP_MODES;\n    private _scaleMode?: SCALE_MODES;\n    private _wrapMode?: WRAP_MODES;\n\n    /**\n     * @param {PIXI.Resource|HTMLImageElement|HTMLVideoElement|ImageBitmap|ICanvas|string} [resource=null] -\n     *        The current resource to use, for things that aren't Resource objects, will be converted\n     *        into a Resource.\n     * @param options - Collection of options\n     * @param {PIXI.MIPMAP_MODES} [options.mipmap=PIXI.settings.MIPMAP_TEXTURES] - If mipmapping is enabled for texture\n     * @param {number} [options.anisotropicLevel=PIXI.settings.ANISOTROPIC_LEVEL] - Anisotropic filtering level of texture\n     * @param {PIXI.WRAP_MODES} [options.wrapMode=PIXI.settings.WRAP_MODE] - Wrap mode for textures\n     * @param {PIXI.SCALE_MODES} [options.scaleMode=PIXI.settings.SCALE_MODE] - Default scale mode, linear, nearest\n     * @param {PIXI.FORMATS} [options.format=PIXI.FORMATS.RGBA] - GL format type\n     * @param {PIXI.TYPES} [options.type=PIXI.TYPES.UNSIGNED_BYTE] - GL data type\n     * @param {PIXI.TARGETS} [options.target=PIXI.TARGETS.TEXTURE_2D] - GL texture target\n     * @param {PIXI.ALPHA_MODES} [options.alphaMode=PIXI.ALPHA_MODES.UNPACK] - Pre multiply the image alpha\n     * @param {number} [options.width=0] - Width of the texture\n     * @param {number} [options.height=0] - Height of the texture\n     * @param {number} [options.resolution=PIXI.settings.RESOLUTION] - Resolution of the base texture\n     * @param {object} [options.resourceOptions] - Optional resource options,\n     *        see {@link PIXI.autoDetectResource autoDetectResource}\n     */\n    constructor(resource: R | ImageSource | string | any = null, options: IBaseTextureOptions<RO> = null)\n    {\n        super();\n\n        options = options || {};\n\n        const { alphaMode, mipmap, anisotropicLevel, scaleMode, width, height,\n            wrapMode, format, type, target, resolution, resourceOptions } = options;\n\n        // Convert the resource to a Resource object\n        if (resource && !(resource instanceof Resource))\n        {\n            resource = autoDetectResource<R, RO>(resource, resourceOptions);\n            resource.internal = true;\n        }\n\n        this.resolution = resolution || settings.RESOLUTION;\n        this.width = Math.round((width || 0) * this.resolution) / this.resolution;\n        this.height = Math.round((height || 0) * this.resolution) / this.resolution;\n        this._mipmap = mipmap ?? settings.MIPMAP_TEXTURES;\n        this.anisotropicLevel = anisotropicLevel ?? settings.ANISOTROPIC_LEVEL;\n        this._wrapMode = wrapMode || settings.WRAP_MODE;\n        this._scaleMode = scaleMode ?? settings.SCALE_MODE;\n        this.format = format || FORMATS.RGBA;\n        this.type = type || TYPES.UNSIGNED_BYTE;\n        this.target = target || TARGETS.TEXTURE_2D;\n        this.alphaMode = alphaMode ?? ALPHA_MODES.UNPACK;\n\n        this.uid = uid();\n        this.touched = 0;\n        this.isPowerOfTwo = false;\n        this._refreshPOT();\n\n        this._glTextures = {};\n        this.dirtyId = 0;\n        this.dirtyStyleId = 0;\n        this.cacheId = null;\n        this.valid = width > 0 && height > 0;\n        this.textureCacheIds = [];\n        this.destroyed = false;\n        this.resource = null;\n\n        this._batchEnabled = 0;\n        this._batchLocation = 0;\n        this.parentTextureArray = null;\n\n        /**\n         * Fired when a not-immediately-available source finishes loading.\n         * @protected\n         * @event PIXI.BaseTexture#loaded\n         * @param {PIXI.BaseTexture} baseTexture - Resource loaded.\n         */\n\n        /**\n         * Fired when a not-immediately-available source fails to load.\n         * @protected\n         * @event PIXI.BaseTexture#error\n         * @param {PIXI.BaseTexture} baseTexture - Resource errored.\n         * @param {ErrorEvent} event - Load error event.\n         */\n\n        /**\n         * Fired when BaseTexture is updated.\n         * @protected\n         * @event PIXI.BaseTexture#loaded\n         * @param {PIXI.BaseTexture} baseTexture - Resource loaded.\n         */\n\n        /**\n         * Fired when BaseTexture is updated.\n         * @protected\n         * @event PIXI.BaseTexture#update\n         * @param {PIXI.BaseTexture} baseTexture - Instance of texture being updated.\n         */\n\n        /**\n         * Fired when BaseTexture is destroyed.\n         * @protected\n         * @event PIXI.BaseTexture#dispose\n         * @param {PIXI.BaseTexture} baseTexture - Instance of texture being destroyed.\n         */\n\n        // Set the resource\n        this.setResource(resource);\n    }\n\n    /**\n     * Pixel width of the source of this texture\n     * @readonly\n     */\n    get realWidth(): number\n    {\n        return Math.round(this.width * this.resolution);\n    }\n\n    /**\n     * Pixel height of the source of this texture\n     * @readonly\n     */\n    get realHeight(): number\n    {\n        return Math.round(this.height * this.resolution);\n    }\n\n    /**\n     * Mipmap mode of the texture, affects downscaled images\n     * @default PIXI.settings.MIPMAP_TEXTURES\n     */\n    get mipmap(): MIPMAP_MODES\n    {\n        return this._mipmap;\n    }\n    set mipmap(value: MIPMAP_MODES)\n    {\n        if (this._mipmap !== value)\n        {\n            this._mipmap = value;\n            this.dirtyStyleId++;\n        }\n    }\n\n    /**\n     * The scale mode to apply when scaling this texture\n     * @default PIXI.settings.SCALE_MODE\n     */\n    get scaleMode(): SCALE_MODES\n    {\n        return this._scaleMode;\n    }\n    set scaleMode(value: SCALE_MODES)\n    {\n        if (this._scaleMode !== value)\n        {\n            this._scaleMode = value;\n            this.dirtyStyleId++;\n        }\n    }\n\n    /**\n     * How the texture wraps\n     * @default PIXI.settings.WRAP_MODE\n     */\n    get wrapMode(): WRAP_MODES\n    {\n        return this._wrapMode;\n    }\n    set wrapMode(value: WRAP_MODES)\n    {\n        if (this._wrapMode !== value)\n        {\n            this._wrapMode = value;\n            this.dirtyStyleId++;\n        }\n    }\n\n    /**\n     * Changes style options of BaseTexture\n     * @param scaleMode - Pixi scalemode\n     * @param mipmap - enable mipmaps\n     * @returns - this\n     */\n    setStyle(scaleMode?: SCALE_MODES, mipmap?: MIPMAP_MODES): this\n    {\n        let dirty;\n\n        if (scaleMode !== undefined && scaleMode !== this.scaleMode)\n        {\n            this.scaleMode = scaleMode;\n            dirty = true;\n        }\n\n        if (mipmap !== undefined && mipmap !== this.mipmap)\n        {\n            this.mipmap = mipmap;\n            dirty = true;\n        }\n\n        if (dirty)\n        {\n            this.dirtyStyleId++;\n        }\n\n        return this;\n    }\n\n    /**\n     * Changes w/h/resolution. Texture becomes valid if width and height are greater than zero.\n     * @param desiredWidth - Desired visual width\n     * @param desiredHeight - Desired visual height\n     * @param resolution - Optionally set resolution\n     * @returns - this\n     */\n    setSize(desiredWidth: number, desiredHeight: number, resolution?: number): this\n    {\n        resolution = resolution || this.resolution;\n\n        return this.setRealSize(desiredWidth * resolution, desiredHeight * resolution, resolution);\n    }\n\n    /**\n     * Sets real size of baseTexture, preserves current resolution.\n     * @param realWidth - Full rendered width\n     * @param realHeight - Full rendered height\n     * @param resolution - Optionally set resolution\n     * @returns - this\n     */\n    setRealSize(realWidth: number, realHeight: number, resolution?: number): this\n    {\n        this.resolution = resolution || this.resolution;\n        this.width = Math.round(realWidth) / this.resolution;\n        this.height = Math.round(realHeight) / this.resolution;\n        this._refreshPOT();\n        this.update();\n\n        return this;\n    }\n\n    /**\n     * Refresh check for isPowerOfTwo texture based on size\n     * @private\n     */\n    protected _refreshPOT(): void\n    {\n        this.isPowerOfTwo = isPow2(this.realWidth) && isPow2(this.realHeight);\n    }\n\n    /**\n     * Changes resolution\n     * @param resolution - res\n     * @returns - this\n     */\n    setResolution(resolution: number): this\n    {\n        const oldResolution = this.resolution;\n\n        if (oldResolution === resolution)\n        {\n            return this;\n        }\n\n        this.resolution = resolution;\n\n        if (this.valid)\n        {\n            this.width = Math.round(this.width * oldResolution) / resolution;\n            this.height = Math.round(this.height * oldResolution) / resolution;\n            this.emit('update', this);\n        }\n\n        this._refreshPOT();\n\n        return this;\n    }\n\n    /**\n     * Sets the resource if it wasn't set. Throws error if resource already present\n     * @param resource - that is managing this BaseTexture\n     * @returns - this\n     */\n    setResource(resource: R): this\n    {\n        if (this.resource === resource)\n        {\n            return this;\n        }\n\n        if (this.resource)\n        {\n            throw new Error('Resource can be set only once');\n        }\n\n        resource.bind(this);\n\n        this.resource = resource;\n\n        return this;\n    }\n\n    /** Invalidates the object. Texture becomes valid if width and height are greater than zero. */\n    update(): void\n    {\n        if (!this.valid)\n        {\n            if (this.width > 0 && this.height > 0)\n            {\n                this.valid = true;\n                this.emit('loaded', this);\n                this.emit('update', this);\n            }\n        }\n        else\n        {\n            this.dirtyId++;\n            this.dirtyStyleId++;\n            this.emit('update', this);\n        }\n    }\n\n    /**\n     * Handle errors with resources.\n     * @private\n     * @param event - Error event emitted.\n     */\n    onError(event: ErrorEvent): void\n    {\n        this.emit('error', this, event);\n    }\n\n    /**\n     * Destroys this base texture.\n     * The method stops if resource doesn't want this texture to be destroyed.\n     * Removes texture from all caches.\n     */\n    destroy(): void\n    {\n        // remove and destroy the resource\n        if (this.resource)\n        {\n            this.resource.unbind(this);\n            // only destroy resourced created internally\n            if (this.resource.internal)\n            {\n                this.resource.destroy();\n            }\n            this.resource = null;\n        }\n\n        if (this.cacheId)\n        {\n            delete BaseTextureCache[this.cacheId];\n            delete TextureCache[this.cacheId];\n\n            this.cacheId = null;\n        }\n\n        // finally let the WebGL renderer know..\n        this.dispose();\n\n        BaseTexture.removeFromCache(this);\n        this.textureCacheIds = null;\n\n        this.destroyed = true;\n    }\n\n    /**\n     * Frees the texture from WebGL memory without destroying this texture object.\n     * This means you can still use the texture later which will upload it to GPU\n     * memory again.\n     * @fires PIXI.BaseTexture#dispose\n     */\n    dispose(): void\n    {\n        this.emit('dispose', this);\n    }\n\n    /** Utility function for BaseTexture|Texture cast. */\n    castToBaseTexture(): BaseTexture\n    {\n        return this;\n    }\n\n    /**\n     * Helper function that creates a base texture based on the source you provide.\n     * The source can be - image url, image element, canvas element. If the\n     * source is an image url or an image element and not in the base texture\n     * cache, it will be created and loaded.\n     * @static\n     * @param {HTMLImageElement|HTMLVideoElement|ImageBitmap|PIXI.ICanvas|string|string[]} source - The\n     *        source to create base texture from.\n     * @param options - See {@link PIXI.BaseTexture}'s constructor for options.\n     * @param {string} [options.pixiIdPrefix=pixiid] - If a source has no id, this is the prefix of the generated id\n     * @param {boolean} [strict] - Enforce strict-mode, see {@link PIXI.settings.STRICT_TEXTURE_CACHE}.\n     * @returns {PIXI.BaseTexture} The new base texture.\n     */\n    static from<R extends Resource = Resource, RO = IAutoDetectOptions>(source: ImageSource | string | string[],\n        options?: IBaseTextureOptions<RO>, strict = settings.STRICT_TEXTURE_CACHE): BaseTexture<R>\n    {\n        const isFrame = typeof source === 'string';\n        let cacheId = null;\n\n        if (isFrame)\n        {\n            cacheId = source;\n        }\n        else\n        {\n            if (!(source as any)._pixiId)\n            {\n                const prefix = options?.pixiIdPrefix || 'pixiid';\n\n                (source as any)._pixiId = `${prefix}_${uid()}`;\n            }\n\n            cacheId = (source as any)._pixiId;\n        }\n\n        let baseTexture = BaseTextureCache[cacheId] as BaseTexture<R>;\n\n        // Strict-mode rejects invalid cacheIds\n        if (isFrame && strict && !baseTexture)\n        {\n            throw new Error(`The cacheId \"${cacheId}\" does not exist in BaseTextureCache.`);\n        }\n\n        if (!baseTexture)\n        {\n            baseTexture = new BaseTexture<R>(source, options);\n            baseTexture.cacheId = cacheId;\n            BaseTexture.addToCache(baseTexture, cacheId);\n        }\n\n        return baseTexture;\n    }\n\n    /**\n     * Create a new BaseTexture with a BufferResource from a Float32Array.\n     * RGBA values are floats from 0 to 1.\n     * @param {Float32Array|Uint8Array} buffer - The optional array to use, if no data\n     *        is provided, a new Float32Array is created.\n     * @param width - Width of the resource\n     * @param height - Height of the resource\n     * @param options - See {@link PIXI.BaseTexture}'s constructor for options.\n     *        Default properties are different from the constructor's defaults.\n     * @param {PIXI.FORMATS} [options.format=PIXI.FORMATS.RGBA] - GL format type\n     * @param {PIXI.ALPHA_MODES} [options.alphaMode=PIXI.ALPHA_MODES.NPM] - Image alpha, not premultiplied by default\n     * @param {PIXI.SCALE_MODES} [options.scaleMode=PIXI.SCALE_MODES.NEAREST] - Scale mode, pixelating by default\n     * @returns - The resulting new BaseTexture\n     */\n    static fromBuffer(buffer: Float32Array | Uint8Array,\n        width: number, height: number, options?: IBaseTextureOptions): BaseTexture<BufferResource>\n    {\n        buffer = buffer || new Float32Array(width * height * 4);\n\n        const resource = new BufferResource(buffer, { width, height });\n        const type = buffer instanceof Float32Array ? TYPES.FLOAT : TYPES.UNSIGNED_BYTE;\n\n        return new BaseTexture(resource, Object.assign({}, defaultBufferOptions, options || { width, height, type }));\n    }\n\n    /**\n     * Adds a BaseTexture to the global BaseTextureCache. This cache is shared across the whole PIXI object.\n     * @param {PIXI.BaseTexture} baseTexture - The BaseTexture to add to the cache.\n     * @param {string} id - The id that the BaseTexture will be stored against.\n     */\n    static addToCache(baseTexture: BaseTexture, id: string): void\n    {\n        if (id)\n        {\n            if (!baseTexture.textureCacheIds.includes(id))\n            {\n                baseTexture.textureCacheIds.push(id);\n            }\n\n            if (BaseTextureCache[id])\n            {\n                // eslint-disable-next-line no-console\n                console.warn(`BaseTexture added to the cache with an id [${id}] that already had an entry`);\n            }\n\n            BaseTextureCache[id] = baseTexture;\n        }\n    }\n\n    /**\n     * Remove a BaseTexture from the global BaseTextureCache.\n     * @param {string|PIXI.BaseTexture} baseTexture - id of a BaseTexture to be removed, or a BaseTexture instance itself.\n     * @returns {PIXI.BaseTexture|null} The BaseTexture that was removed.\n     */\n    static removeFromCache(baseTexture: string | BaseTexture): BaseTexture | null\n    {\n        if (typeof baseTexture === 'string')\n        {\n            const baseTextureFromCache = BaseTextureCache[baseTexture];\n\n            if (baseTextureFromCache)\n            {\n                const index = baseTextureFromCache.textureCacheIds.indexOf(baseTexture);\n\n                if (index > -1)\n                {\n                    baseTextureFromCache.textureCacheIds.splice(index, 1);\n                }\n\n                delete BaseTextureCache[baseTexture];\n\n                return baseTextureFromCache;\n            }\n        }\n        else if (baseTexture?.textureCacheIds)\n        {\n            for (let i = 0; i < baseTexture.textureCacheIds.length; ++i)\n            {\n                delete BaseTextureCache[baseTexture.textureCacheIds[i]];\n            }\n\n            baseTexture.textureCacheIds.length = 0;\n\n            return baseTexture;\n        }\n\n        return null;\n    }\n\n    /** Global number of the texture batch, used by multi-texture renderers. */\n    static _globalBatch = 0;\n}\n"],"names":["SCALE_MODES","FORMATS","ALPHA_MODES","EventEmitter","Resource","autoDetectResource","settings","TYPES","TARGETS","uid","isPow2","BaseTextureCache","TextureCache","BufferResource"],"mappings":";;;;;;;;;;;AAYA,MAAM,oBAAuB,GAAA;AAAA,EACzB,WAAWA,qBAAY,CAAA,OAAA;AAAA,EACvB,QAAQC,iBAAQ,CAAA,IAAA;AAAA,EAChB,WAAWC,qBAAY,CAAA,GAAA;AAC3B,CAAA,CAAA;AAgCO,MAAM,YAAA,GAAN,cAAkFC,kBACzF,CAAA;AAAA,EAyKI,WAAY,CAAA,QAAA,GAA2C,IAAM,EAAA,OAAA,GAAmC,IAChG,EAAA;AACI,IAAM,KAAA,EAAA,CAAA;AAEN,IAAA,OAAA,GAAU,WAAW,EAAC,CAAA;AAEtB,IAAM,MAAA;AAAA,MAAE,SAAA;AAAA,MAAW,MAAA;AAAA,MAAQ,gBAAA;AAAA,MAAkB,SAAA;AAAA,MAAW,KAAA;AAAA,MAAO,MAAA;AAAA,MAC3D,QAAA;AAAA,MAAU,MAAA;AAAA,MAAQ,IAAA;AAAA,MAAM,MAAA;AAAA,MAAQ,UAAA;AAAA,MAAY,eAAA;AAAA,KAAoB,GAAA,OAAA,CAAA;AAGpE,IAAI,IAAA,QAAA,IAAY,EAAE,QAAA,YAAoBC,iBACtC,CAAA,EAAA;AACI,MAAW,QAAA,GAAAC,qCAAA,CAA0B,UAAU,eAAe,CAAA,CAAA;AAC9D,MAAA,QAAA,CAAS,QAAW,GAAA,IAAA,CAAA;AAAA,KACxB;AAEA,IAAK,IAAA,CAAA,UAAA,GAAa,cAAcC,iBAAS,CAAA,UAAA,CAAA;AACzC,IAAK,IAAA,CAAA,KAAA,GAAQ,KAAK,KAAO,CAAA,CAAA,KAAA,IAAS,KAAK,IAAK,CAAA,UAAU,IAAI,IAAK,CAAA,UAAA,CAAA;AAC/D,IAAK,IAAA,CAAA,MAAA,GAAS,KAAK,KAAO,CAAA,CAAA,MAAA,IAAU,KAAK,IAAK,CAAA,UAAU,IAAI,IAAK,CAAA,UAAA,CAAA;AACjE,IAAK,IAAA,CAAA,OAAA,GAAU,UAAUA,iBAAS,CAAA,eAAA,CAAA;AAClC,IAAK,IAAA,CAAA,gBAAA,GAAmB,oBAAoBA,iBAAS,CAAA,iBAAA,CAAA;AACrD,IAAK,IAAA,CAAA,SAAA,GAAY,YAAYA,iBAAS,CAAA,SAAA,CAAA;AACtC,IAAK,IAAA,CAAA,UAAA,GAAa,aAAaA,iBAAS,CAAA,UAAA,CAAA;AACxC,IAAK,IAAA,CAAA,MAAA,GAAS,UAAUL,iBAAQ,CAAA,IAAA,CAAA;AAChC,IAAK,IAAA,CAAA,IAAA,GAAO,QAAQM,eAAM,CAAA,aAAA,CAAA;AAC1B,IAAK,IAAA,CAAA,MAAA,GAAS,UAAUC,iBAAQ,CAAA,UAAA,CAAA;AAChC,IAAK,IAAA,CAAA,SAAA,GAAY,aAAaN,qBAAY,CAAA,MAAA,CAAA;AAE1C,IAAA,IAAA,CAAK,MAAMO,SAAI,EAAA,CAAA;AACf,IAAA,IAAA,CAAK,OAAU,GAAA,CAAA,CAAA;AACf,IAAA,IAAA,CAAK,YAAe,GAAA,KAAA,CAAA;AACpB,IAAA,IAAA,CAAK,WAAY,EAAA,CAAA;AAEjB,IAAA,IAAA,CAAK,cAAc,EAAC,CAAA;AACpB,IAAA,IAAA,CAAK,OAAU,GAAA,CAAA,CAAA;AACf,IAAA,IAAA,CAAK,YAAe,GAAA,CAAA,CAAA;AACpB,IAAA,IAAA,CAAK,OAAU,GAAA,IAAA,CAAA;AACf,IAAK,IAAA,CAAA,KAAA,GAAQ,KAAQ,GAAA,CAAA,IAAK,MAAS,GAAA,CAAA,CAAA;AACnC,IAAA,IAAA,CAAK,kBAAkB,EAAC,CAAA;AACxB,IAAA,IAAA,CAAK,SAAY,GAAA,KAAA,CAAA;AACjB,IAAA,IAAA,CAAK,QAAW,GAAA,IAAA,CAAA;AAEhB,IAAA,IAAA,CAAK,aAAgB,GAAA,CAAA,CAAA;AACrB,IAAA,IAAA,CAAK,cAAiB,GAAA,CAAA,CAAA;AACtB,IAAA,IAAA,CAAK,kBAAqB,GAAA,IAAA,CAAA;AAuC1B,IAAA,IAAA,CAAK,YAAY,QAAQ,CAAA,CAAA;AAAA,GAC7B;AAAA,EAMA,IAAI,SACJ,GAAA;AACI,IAAA,OAAO,IAAK,CAAA,KAAA,CAAM,IAAK,CAAA,KAAA,GAAQ,KAAK,UAAU,CAAA,CAAA;AAAA,GAClD;AAAA,EAMA,IAAI,UACJ,GAAA;AACI,IAAA,OAAO,IAAK,CAAA,KAAA,CAAM,IAAK,CAAA,MAAA,GAAS,KAAK,UAAU,CAAA,CAAA;AAAA,GACnD;AAAA,EAMA,IAAI,MACJ,GAAA;AACI,IAAA,OAAO,IAAK,CAAA,OAAA,CAAA;AAAA,GAChB;AAAA,EACA,IAAI,OAAO,KACX,EAAA;AACI,IAAI,IAAA,IAAA,CAAK,YAAY,KACrB,EAAA;AACI,MAAA,IAAA,CAAK,OAAU,GAAA,KAAA,CAAA;AACf,MAAK,IAAA,CAAA,YAAA,EAAA,CAAA;AAAA,KACT;AAAA,GACJ;AAAA,EAMA,IAAI,SACJ,GAAA;AACI,IAAA,OAAO,IAAK,CAAA,UAAA,CAAA;AAAA,GAChB;AAAA,EACA,IAAI,UAAU,KACd,EAAA;AACI,IAAI,IAAA,IAAA,CAAK,eAAe,KACxB,EAAA;AACI,MAAA,IAAA,CAAK,UAAa,GAAA,KAAA,CAAA;AAClB,MAAK,IAAA,CAAA,YAAA,EAAA,CAAA;AAAA,KACT;AAAA,GACJ;AAAA,EAMA,IAAI,QACJ,GAAA;AACI,IAAA,OAAO,IAAK,CAAA,SAAA,CAAA;AAAA,GAChB;AAAA,EACA,IAAI,SAAS,KACb,EAAA;AACI,IAAI,IAAA,IAAA,CAAK,cAAc,KACvB,EAAA;AACI,MAAA,IAAA,CAAK,SAAY,GAAA,KAAA,CAAA;AACjB,MAAK,IAAA,CAAA,YAAA,EAAA,CAAA;AAAA,KACT;AAAA,GACJ;AAAA,EAQA,QAAA,CAAS,WAAyB,MAClC,EAAA;AACI,IAAI,IAAA,KAAA,CAAA;AAEJ,IAAA,IAAI,SAAc,KAAA,KAAA,CAAA,IAAa,SAAc,KAAA,IAAA,CAAK,SAClD,EAAA;AACI,MAAA,IAAA,CAAK,SAAY,GAAA,SAAA,CAAA;AACjB,MAAQ,KAAA,GAAA,IAAA,CAAA;AAAA,KACZ;AAEA,IAAA,IAAI,MAAW,KAAA,KAAA,CAAA,IAAa,MAAW,KAAA,IAAA,CAAK,MAC5C,EAAA;AACI,MAAA,IAAA,CAAK,MAAS,GAAA,MAAA,CAAA;AACd,MAAQ,KAAA,GAAA,IAAA,CAAA;AAAA,KACZ;AAEA,IAAA,IAAI,KACJ,EAAA;AACI,MAAK,IAAA,CAAA,YAAA,EAAA,CAAA;AAAA,KACT;AAEA,IAAO,OAAA,IAAA,CAAA;AAAA,GACX;AAAA,EASA,OAAA,CAAQ,YAAsB,EAAA,aAAA,EAAuB,UACrD,EAAA;AACI,IAAA,UAAA,GAAa,cAAc,IAAK,CAAA,UAAA,CAAA;AAEhC,IAAA,OAAO,KAAK,WAAY,CAAA,YAAA,GAAe,UAAY,EAAA,aAAA,GAAgB,YAAY,UAAU,CAAA,CAAA;AAAA,GAC7F;AAAA,EASA,WAAA,CAAY,SAAmB,EAAA,UAAA,EAAoB,UACnD,EAAA;AACI,IAAK,IAAA,CAAA,UAAA,GAAa,cAAc,IAAK,CAAA,UAAA,CAAA;AACrC,IAAA,IAAA,CAAK,KAAQ,GAAA,IAAA,CAAK,KAAM,CAAA,SAAS,IAAI,IAAK,CAAA,UAAA,CAAA;AAC1C,IAAA,IAAA,CAAK,MAAS,GAAA,IAAA,CAAK,KAAM,CAAA,UAAU,IAAI,IAAK,CAAA,UAAA,CAAA;AAC5C,IAAA,IAAA,CAAK,WAAY,EAAA,CAAA;AACjB,IAAA,IAAA,CAAK,MAAO,EAAA,CAAA;AAEZ,IAAO,OAAA,IAAA,CAAA;AAAA,GACX;AAAA,EAMA,WACA,GAAA;AACI,IAAA,IAAA,CAAK,eAAeC,YAAO,CAAA,IAAA,CAAK,SAAS,CAAK,IAAAA,YAAA,CAAO,KAAK,UAAU,CAAA,CAAA;AAAA,GACxE;AAAA,EAOA,cAAc,UACd,EAAA;AACI,IAAA,MAAM,gBAAgB,IAAK,CAAA,UAAA,CAAA;AAE3B,IAAA,IAAI,kBAAkB,UACtB,EAAA;AACI,MAAO,OAAA,IAAA,CAAA;AAAA,KACX;AAEA,IAAA,IAAA,CAAK,UAAa,GAAA,UAAA,CAAA;AAElB,IAAA,IAAI,KAAK,KACT,EAAA;AACI,MAAA,IAAA,CAAK,QAAQ,IAAK,CAAA,KAAA,CAAM,IAAK,CAAA,KAAA,GAAQ,aAAa,CAAI,GAAA,UAAA,CAAA;AACtD,MAAA,IAAA,CAAK,SAAS,IAAK,CAAA,KAAA,CAAM,IAAK,CAAA,MAAA,GAAS,aAAa,CAAI,GAAA,UAAA,CAAA;AACxD,MAAK,IAAA,CAAA,IAAA,CAAK,UAAU,IAAI,CAAA,CAAA;AAAA,KAC5B;AAEA,IAAA,IAAA,CAAK,WAAY,EAAA,CAAA;AAEjB,IAAO,OAAA,IAAA,CAAA;AAAA,GACX;AAAA,EAOA,YAAY,QACZ,EAAA;AACI,IAAI,IAAA,IAAA,CAAK,aAAa,QACtB,EAAA;AACI,MAAO,OAAA,IAAA,CAAA;AAAA,KACX;AAEA,IAAA,IAAI,KAAK,QACT,EAAA;AACI,MAAM,MAAA,IAAI,MAAM,+BAA+B,CAAA,CAAA;AAAA,KACnD;AAEA,IAAA,QAAA,CAAS,KAAK,IAAI,CAAA,CAAA;AAElB,IAAA,IAAA,CAAK,QAAW,GAAA,QAAA,CAAA;AAEhB,IAAO,OAAA,IAAA,CAAA;AAAA,GACX;AAAA,EAGA,MACA,GAAA;AACI,IAAI,IAAA,CAAC,KAAK,KACV,EAAA;AACI,MAAA,IAAI,IAAK,CAAA,KAAA,GAAQ,CAAK,IAAA,IAAA,CAAK,SAAS,CACpC,EAAA;AACI,QAAA,IAAA,CAAK,KAAQ,GAAA,IAAA,CAAA;AACb,QAAK,IAAA,CAAA,IAAA,CAAK,UAAU,IAAI,CAAA,CAAA;AACxB,QAAK,IAAA,CAAA,IAAA,CAAK,UAAU,IAAI,CAAA,CAAA;AAAA,OAC5B;AAAA,KAGJ,MAAA;AACI,MAAK,IAAA,CAAA,OAAA,EAAA,CAAA;AACL,MAAK,IAAA,CAAA,YAAA,EAAA,CAAA;AACL,MAAK,IAAA,CAAA,IAAA,CAAK,UAAU,IAAI,CAAA,CAAA;AAAA,KAC5B;AAAA,GACJ;AAAA,EAOA,QAAQ,KACR,EAAA;AACI,IAAK,IAAA,CAAA,IAAA,CAAK,OAAS,EAAA,IAAA,EAAM,KAAK,CAAA,CAAA;AAAA,GAClC;AAAA,EAOA,OACA,GAAA;AAEI,IAAA,IAAI,KAAK,QACT,EAAA;AACI,MAAK,IAAA,CAAA,QAAA,CAAS,OAAO,IAAI,CAAA,CAAA;AAEzB,MAAI,IAAA,IAAA,CAAK,SAAS,QAClB,EAAA;AACI,QAAA,IAAA,CAAK,SAAS,OAAQ,EAAA,CAAA;AAAA,OAC1B;AACA,MAAA,IAAA,CAAK,QAAW,GAAA,IAAA,CAAA;AAAA,KACpB;AAEA,IAAA,IAAI,KAAK,OACT,EAAA;AACI,MAAA,OAAOC,uBAAiB,IAAK,CAAA,OAAA,CAAA,CAAA;AAC7B,MAAA,OAAOC,mBAAa,IAAK,CAAA,OAAA,CAAA,CAAA;AAEzB,MAAA,IAAA,CAAK,OAAU,GAAA,IAAA,CAAA;AAAA,KACnB;AAGA,IAAA,IAAA,CAAK,OAAQ,EAAA,CAAA;AAEb,IAAA,YAAA,CAAY,gBAAgB,IAAI,CAAA,CAAA;AAChC,IAAA,IAAA,CAAK,eAAkB,GAAA,IAAA,CAAA;AAEvB,IAAA,IAAA,CAAK,SAAY,GAAA,IAAA,CAAA;AAAA,GACrB;AAAA,EAQA,OACA,GAAA;AACI,IAAK,IAAA,CAAA,IAAA,CAAK,WAAW,IAAI,CAAA,CAAA;AAAA,GAC7B;AAAA,EAGA,iBACA,GAAA;AACI,IAAO,OAAA,IAAA,CAAA;AAAA,GACX;AAAA,EAeA,OAAO,IAA6D,CAAA,MAAA,EAChE,OAAmC,EAAA,MAAA,GAASN,kBAAS,oBACzD,EAAA;AACI,IAAM,MAAA,OAAA,GAAU,OAAO,MAAW,KAAA,QAAA,CAAA;AAClC,IAAA,IAAI,OAAU,GAAA,IAAA,CAAA;AAEd,IAAA,IAAI,OACJ,EAAA;AACI,MAAU,OAAA,GAAA,MAAA,CAAA;AAAA,KAGd,MAAA;AACI,MAAI,IAAA,CAAE,OAAe,OACrB,EAAA;AACI,QAAM,MAAA,MAAA,GAAS,SAAS,YAAgB,IAAA,QAAA,CAAA;AAExC,QAAC,MAAe,CAAA,OAAA,GAAU,CAAG,EAAA,MAAA,CAAA,CAAA,EAAUG,SAAI,EAAA,CAAA,CAAA,CAAA;AAAA,OAC/C;AAEA,MAAA,OAAA,GAAW,MAAe,CAAA,OAAA,CAAA;AAAA,KAC9B;AAEA,IAAA,IAAI,cAAcE,sBAAiB,CAAA,OAAA,CAAA,CAAA;AAGnC,IAAI,IAAA,OAAA,IAAW,MAAU,IAAA,CAAC,WAC1B,EAAA;AACI,MAAM,MAAA,IAAI,KAAM,CAAA,CAAA,aAAA,EAAgB,OAA8C,CAAA,qCAAA,CAAA,CAAA,CAAA;AAAA,KAClF;AAEA,IAAA,IAAI,CAAC,WACL,EAAA;AACI,MAAc,WAAA,GAAA,IAAI,YAAe,CAAA,MAAA,EAAQ,OAAO,CAAA,CAAA;AAChD,MAAA,WAAA,CAAY,OAAU,GAAA,OAAA,CAAA;AACtB,MAAY,YAAA,CAAA,UAAA,CAAW,aAAa,OAAO,CAAA,CAAA;AAAA,KAC/C;AAEA,IAAO,OAAA,WAAA,CAAA;AAAA,GACX;AAAA,EAgBA,OAAO,UAAA,CAAW,MACd,EAAA,KAAA,EAAe,QAAgB,OACnC,EAAA;AACI,IAAA,MAAA,GAAS,MAAU,IAAA,IAAI,YAAa,CAAA,KAAA,GAAQ,SAAS,CAAC,CAAA,CAAA;AAEtD,IAAA,MAAM,WAAW,IAAIE,6BAAA,CAAe,QAAQ,EAAE,KAAA,EAAO,QAAQ,CAAA,CAAA;AAC7D,IAAA,MAAM,IAAO,GAAA,MAAA,YAAkB,YAAe,GAAAN,eAAA,CAAM,QAAQA,eAAM,CAAA,aAAA,CAAA;AAElE,IAAA,OAAO,IAAI,YAAA,CAAY,QAAU,EAAA,MAAA,CAAO,OAAO,EAAC,EAAG,oBAAsB,EAAA,OAAA,IAAW,EAAE,KAAA,EAAO,MAAQ,EAAA,IAAA,EAAM,CAAC,CAAA,CAAA;AAAA,GAChH;AAAA,EAOA,OAAO,UAAW,CAAA,WAAA,EAA0B,EAC5C,EAAA;AACI,IAAA,IAAI,EACJ,EAAA;AACI,MAAA,IAAI,CAAC,WAAA,CAAY,eAAgB,CAAA,QAAA,CAAS,EAAE,CAC5C,EAAA;AACI,QAAY,WAAA,CAAA,eAAA,CAAgB,KAAK,EAAE,CAAA,CAAA;AAAA,OACvC;AAEA,MAAA,IAAII,uBAAiB,EACrB,CAAA,EAAA;AAEI,QAAQ,OAAA,CAAA,IAAA,CAAK,8CAA8C,EAA+B,CAAA,2BAAA,CAAA,CAAA,CAAA;AAAA,OAC9F;AAEA,MAAAA,sBAAA,CAAiB,EAAM,CAAA,GAAA,WAAA,CAAA;AAAA,KAC3B;AAAA,GACJ;AAAA,EAOA,OAAO,gBAAgB,WACvB,EAAA;AACI,IAAI,IAAA,OAAO,gBAAgB,QAC3B,EAAA;AACI,MAAA,MAAM,uBAAuBA,sBAAiB,CAAA,WAAA,CAAA,CAAA;AAE9C,MAAA,IAAI,oBACJ,EAAA;AACI,QAAA,MAAM,KAAQ,GAAA,oBAAA,CAAqB,eAAgB,CAAA,OAAA,CAAQ,WAAW,CAAA,CAAA;AAEtE,QAAA,IAAI,QAAQ,CACZ,CAAA,EAAA;AACI,UAAqB,oBAAA,CAAA,eAAA,CAAgB,MAAO,CAAA,KAAA,EAAO,CAAC,CAAA,CAAA;AAAA,SACxD;AAEA,QAAA,OAAOA,sBAAiB,CAAA,WAAA,CAAA,CAAA;AAExB,QAAO,OAAA,oBAAA,CAAA;AAAA,OACX;AAAA,KACJ,MAAA,IACS,aAAa,eACtB,EAAA;AACI,MAAA,KAAA,IAAS,IAAI,CAAG,EAAA,CAAA,GAAI,YAAY,eAAgB,CAAA,MAAA,EAAQ,EAAE,CAC1D,EAAA;AACI,QAAO,OAAAA,sBAAA,CAAiB,YAAY,eAAgB,CAAA,CAAA,CAAA,CAAA,CAAA;AAAA,OACxD;AAEA,MAAA,WAAA,CAAY,gBAAgB,MAAS,GAAA,CAAA,CAAA;AAErC,MAAO,OAAA,WAAA,CAAA;AAAA,KACX;AAEA,IAAO,OAAA,IAAA,CAAA;AAAA,GACX;AAIJ,CAAA,CAAA;AAnqBO,IAAM,WAAN,GAAA,aAAA;AAAM,YAkqBF,YAAe,GAAA,CAAA;;;;"}