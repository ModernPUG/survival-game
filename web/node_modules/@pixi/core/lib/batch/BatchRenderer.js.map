{"version":3,"file":"BatchRenderer.js","sources":["../../src/batch/BatchRenderer.ts"],"sourcesContent":["import { BatchDrawCall } from './BatchDrawCall';\nimport { BatchTextureArray } from './BatchTextureArray';\nimport { BaseTexture } from '../textures/BaseTexture';\nimport { ObjectRenderer } from './ObjectRenderer';\nimport { State } from '../state/State';\nimport { ViewableBuffer } from '../geometry/ViewableBuffer';\nimport { BatchShaderGenerator } from './BatchShaderGenerator';\nimport { checkMaxIfStatementsInShader } from '../shader/utils/checkMaxIfStatementsInShader';\n\nimport { settings } from '@pixi/settings';\nimport { premultiplyBlendMode, premultiplyTint, nextPow2, log2 } from '@pixi/utils';\nimport { ENV } from '@pixi/constants';\nimport { BatchGeometry } from './BatchGeometry';\n\nimport defaultVertex from './texture.vert';\nimport defaultFragment from './texture.frag';\n\nimport type { Renderer } from '../Renderer';\nimport type { Shader } from '../shader/Shader';\nimport type { Texture } from '../textures/Texture';\nimport type { BLEND_MODES } from '@pixi/constants';\nimport type { ExtensionMetadata } from '@pixi/extensions';\nimport { extensions, ExtensionType } from '@pixi/extensions';\n\n/**\n * Interface for elements like Sprite, Mesh etc. for batching.\n * @memberof PIXI\n */\nexport interface IBatchableElement\n{\n    _texture: Texture;\n    vertexData: Float32Array;\n    indices: Uint16Array | Uint32Array | Array<number>;\n    uvs: Float32Array;\n    worldAlpha: number;\n    _tintRGB: number;\n    blendMode: BLEND_MODES;\n}\n\n/**\n * Renderer dedicated to drawing and batching sprites.\n *\n * This is the default batch renderer. It buffers objects\n * with texture-based geometries and renders them in\n * batches. It uploads multiple textures to the GPU to\n * reduce to the number of draw calls.\n * @memberof PIXI\n */\nexport class BatchRenderer extends ObjectRenderer\n{\n    /** @ignore */\n    static extension: ExtensionMetadata = {\n        name: 'batch',\n        type: ExtensionType.RendererPlugin,\n    };\n\n    /** The WebGL state in which this renderer will work. */\n    public readonly state: State;\n\n    /**\n     * The number of bufferable objects before a flush\n     * occurs automatically.\n     * @default settings.SPRITE_BATCH_SIZE * 4\n     */\n    public size: number;\n\n    /**\n     * Maximum number of textures that can be uploaded to\n     * the GPU under the current context. It is initialized\n     * properly in `this.contextChange`.\n     * @see PIXI.BatchRenderer#contextChange\n     * @readonly\n     */\n    public MAX_TEXTURES: number;\n\n    /**\n     * This is used to generate a shader that can\n     * color each vertex based on a `aTextureId`\n     * attribute that points to an texture in `uSampler`.\n     *\n     * This enables the objects with different textures\n     * to be drawn in the same draw call.\n     *\n     * You can customize your shader by creating your\n     * custom shader generator.\n     */\n    protected shaderGenerator: BatchShaderGenerator;\n\n    /**\n     * The class that represents the geometry of objects\n     * that are going to be batched with this.\n     * @member {object}\n     * @default PIXI.BatchGeometry\n     */\n    protected geometryClass: typeof BatchGeometry;\n\n    /**\n     * Size of data being buffered per vertex in the\n     * attribute buffers (in floats). By default, the\n     * batch-renderer plugin uses 6:\n     *\n     * | aVertexPosition | 2 |\n     * |-----------------|---|\n     * | aTextureCoords  | 2 |\n     * | aColor          | 1 |\n     * | aTextureId      | 1 |\n     * @default 6\n     */\n    protected vertexSize: number;\n\n    /** Total count of all vertices used by the currently buffered objects. */\n    protected _vertexCount: number;\n\n    /** Total count of all indices used by the currently buffered objects. */\n    protected _indexCount: number;\n\n    /**\n     * Buffer of objects that are yet to be rendered.\n     * @member {PIXI.DisplayObject[]}\n     */\n    protected _bufferedElements: Array<IBatchableElement>;\n\n    /**\n     * Data for texture batch builder, helps to save a bit of CPU on a pass.\n     * @member {PIXI.BaseTexture[]}\n     */\n    protected _bufferedTextures: Array<BaseTexture>;\n\n    /** Number of elements that are buffered and are waiting to be flushed. */\n    protected _bufferSize: number;\n\n    /**\n     * This shader is generated by `this.shaderGenerator`.\n     *\n     * It is generated specifically to handle the required\n     * number of textures being batched together.\n     */\n    protected _shader: Shader;\n\n    /**\n     * A flush may occur multiple times in a single\n     * frame. On iOS devices or when\n     * `settings.CAN_UPLOAD_SAME_BUFFER` is false, the\n     * batch renderer does not upload data to the same\n     * `WebGLBuffer` for performance reasons.\n     *\n     * This is the index into `packedGeometries` that points to\n     * geometry holding the most recent buffers.\n     */\n    protected _flushId: number;\n\n    /**\n     * Pool of `ViewableBuffer` objects that are sorted in\n     * order of increasing size. The flush method uses\n     * the buffer with the least size above the amount\n     * it requires. These are used for passing attributes.\n     *\n     * The first buffer has a size of 8; each subsequent\n     * buffer has double capacity of its previous.\n     * @member {PIXI.ViewableBuffer[]}\n     * @see PIXI.BatchRenderer#getAttributeBuffer\n     */\n    protected _aBuffers: Array<ViewableBuffer>;\n\n    /**\n     * Pool of `Uint16Array` objects that are sorted in\n     * order of increasing size. The flush method uses\n     * the buffer with the least size above the amount\n     * it requires. These are used for passing indices.\n     *\n     * The first buffer has a size of 12; each subsequent\n     * buffer has double capacity of its previous.\n     * @member {Uint16Array[]}\n     * @see PIXI.BatchRenderer#getIndexBuffer\n     */\n    protected _iBuffers: Array<Uint16Array>;\n    protected _dcIndex: number;\n    protected _aIndex: number;\n    protected _iIndex: number;\n    protected _attributeBuffer: ViewableBuffer;\n    protected _indexBuffer: Uint16Array;\n    protected _tempBoundTextures: BaseTexture[];\n\n    /**\n     * Pool of `this.geometryClass` geometry objects\n     * that store buffers. They are used to pass data\n     * to the shader on each draw call.\n     *\n     * These are never re-allocated again, unless a\n     * context change occurs; however, the pool may\n     * be expanded if required.\n     * @member {PIXI.Geometry[]}\n     * @see PIXI.BatchRenderer.contextChange\n     */\n    private _packedGeometries: Array<BatchGeometry>;\n\n    /**\n     * Size of `this._packedGeometries`. It can be expanded\n     * if more than `this._packedGeometryPoolSize` flushes\n     * occur in a single frame.\n     */\n    private _packedGeometryPoolSize: number;\n\n    /**\n     * This will hook onto the renderer's `contextChange`\n     * and `prerender` signals.\n     * @param {PIXI.Renderer} renderer - The renderer this works for.\n     */\n    constructor(renderer: Renderer)\n    {\n        super(renderer);\n\n        this.setShaderGenerator();\n        this.geometryClass = BatchGeometry;\n        this.vertexSize = 6;\n        this.state = State.for2d();\n        this.size = settings.SPRITE_BATCH_SIZE * 4;\n        this._vertexCount = 0;\n        this._indexCount = 0;\n        this._bufferedElements = [];\n        this._bufferedTextures = [];\n        this._bufferSize = 0;\n        this._shader = null;\n        this._packedGeometries = [];\n        this._packedGeometryPoolSize = 2;\n        this._flushId = 0;\n        this._aBuffers = {} as any;\n        this._iBuffers = {} as any;\n\n        this.MAX_TEXTURES = 1;\n\n        this.renderer.on('prerender', this.onPrerender, this);\n        renderer.runners.contextChange.add(this);\n\n        this._dcIndex = 0;\n        this._aIndex = 0;\n        this._iIndex = 0;\n        this._attributeBuffer = null;\n        this._indexBuffer = null;\n        this._tempBoundTextures = [];\n    }\n\n    /**\n     * The default vertex shader source\n     * @readonly\n     */\n    static get defaultVertexSrc(): string\n    {\n        return defaultVertex;\n    }\n\n    /**\n     * The default fragment shader source\n     * @readonly\n     */\n    static get defaultFragmentTemplate(): string\n    {\n        return defaultFragment;\n    }\n\n    /**\n     * Set the shader generator.\n     * @param {object} [options]\n     * @param {string} [options.vertex=PIXI.BatchRenderer.defaultVertexSrc] - Vertex shader source\n     * @param {string} [options.fragment=PIXI.BatchRenderer.defaultFragmentTemplate] - Fragment shader template\n     */\n    public setShaderGenerator({\n        vertex = BatchRenderer.defaultVertexSrc,\n        fragment = BatchRenderer.defaultFragmentTemplate\n    }: { vertex?: string, fragment?: string } = {}): void\n    {\n        this.shaderGenerator = new BatchShaderGenerator(vertex, fragment);\n    }\n\n    /**\n     * Handles the `contextChange` signal.\n     *\n     * It calculates `this.MAX_TEXTURES` and allocating the packed-geometry object pool.\n     */\n    contextChange(): void\n    {\n        const gl = this.renderer.gl;\n\n        if (settings.PREFER_ENV === ENV.WEBGL_LEGACY)\n        {\n            this.MAX_TEXTURES = 1;\n        }\n        else\n        {\n            // step 1: first check max textures the GPU can handle.\n            this.MAX_TEXTURES = Math.min(\n                gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS),\n                settings.SPRITE_MAX_TEXTURES);\n\n            // step 2: check the maximum number of if statements the shader can have too..\n            this.MAX_TEXTURES = checkMaxIfStatementsInShader(\n                this.MAX_TEXTURES, gl);\n        }\n\n        this._shader = this.shaderGenerator.generateShader(this.MAX_TEXTURES);\n\n        // we use the second shader as the first one depending on your browser\n        // may omit aTextureId as it is not used by the shader so is optimized out.\n        for (let i = 0; i < this._packedGeometryPoolSize; i++)\n        {\n            /* eslint-disable max-len */\n            this._packedGeometries[i] = new (this.geometryClass)();\n        }\n\n        this.initFlushBuffers();\n    }\n\n    /** Makes sure that static and dynamic flush pooled objects have correct dimensions. */\n    initFlushBuffers(): void\n    {\n        const {\n            _drawCallPool,\n            _textureArrayPool,\n        } = BatchRenderer;\n        // max draw calls\n        const MAX_SPRITES = this.size / 4;\n        // max texture arrays\n        const MAX_TA = Math.floor(MAX_SPRITES / this.MAX_TEXTURES) + 1;\n\n        while (_drawCallPool.length < MAX_SPRITES)\n        {\n            _drawCallPool.push(new BatchDrawCall());\n        }\n        while (_textureArrayPool.length < MAX_TA)\n        {\n            _textureArrayPool.push(new BatchTextureArray());\n        }\n        for (let i = 0; i < this.MAX_TEXTURES; i++)\n        {\n            this._tempBoundTextures[i] = null;\n        }\n    }\n\n    /** Handles the `prerender` signal. It ensures that flushes start from the first geometry object again. */\n    onPrerender(): void\n    {\n        this._flushId = 0;\n    }\n\n    /**\n     * Buffers the \"batchable\" object. It need not be rendered immediately.\n     * @param {PIXI.DisplayObject} element - the element to render when\n     *    using this renderer\n     */\n    render(element: IBatchableElement): void\n    {\n        if (!element._texture.valid)\n        {\n            return;\n        }\n\n        if (this._vertexCount + (element.vertexData.length / 2) > this.size)\n        {\n            this.flush();\n        }\n\n        this._vertexCount += element.vertexData.length / 2;\n        this._indexCount += element.indices.length;\n        this._bufferedTextures[this._bufferSize] = element._texture.baseTexture;\n        this._bufferedElements[this._bufferSize++] = element;\n    }\n\n    buildTexturesAndDrawCalls(): void\n    {\n        const {\n            _bufferedTextures: textures,\n            MAX_TEXTURES,\n        } = this;\n        const textureArrays = BatchRenderer._textureArrayPool;\n        const batch = this.renderer.batch;\n        const boundTextures = this._tempBoundTextures;\n        const touch = this.renderer.textureGC.count;\n\n        let TICK = ++BaseTexture._globalBatch;\n        let countTexArrays = 0;\n        let texArray = textureArrays[0];\n        let start = 0;\n\n        batch.copyBoundTextures(boundTextures, MAX_TEXTURES);\n\n        for (let i = 0; i < this._bufferSize; ++i)\n        {\n            const tex = textures[i];\n\n            textures[i] = null;\n            if (tex._batchEnabled === TICK)\n            {\n                continue;\n            }\n\n            if (texArray.count >= MAX_TEXTURES)\n            {\n                batch.boundArray(texArray, boundTextures, TICK, MAX_TEXTURES);\n                this.buildDrawCalls(texArray, start, i);\n                start = i;\n                texArray = textureArrays[++countTexArrays];\n                ++TICK;\n            }\n\n            tex._batchEnabled = TICK;\n            tex.touched = touch;\n            texArray.elements[texArray.count++] = tex;\n        }\n\n        if (texArray.count > 0)\n        {\n            batch.boundArray(texArray, boundTextures, TICK, MAX_TEXTURES);\n            this.buildDrawCalls(texArray, start, this._bufferSize);\n            ++countTexArrays;\n            ++TICK;\n        }\n\n        // Clean-up\n\n        for (let i = 0; i < boundTextures.length; i++)\n        {\n            boundTextures[i] = null;\n        }\n        BaseTexture._globalBatch = TICK;\n    }\n\n    /**\n     * Populating drawcalls for rendering\n     * @param texArray\n     * @param start\n     * @param finish\n     */\n    buildDrawCalls(texArray: BatchTextureArray, start: number, finish: number): void\n    {\n        const {\n            _bufferedElements: elements,\n            _attributeBuffer,\n            _indexBuffer,\n            vertexSize,\n        } = this;\n        const drawCalls = BatchRenderer._drawCallPool;\n\n        let dcIndex = this._dcIndex;\n        let aIndex = this._aIndex;\n        let iIndex = this._iIndex;\n\n        let drawCall = drawCalls[dcIndex];\n\n        drawCall.start = this._iIndex;\n        drawCall.texArray = texArray;\n\n        for (let i = start; i < finish; ++i)\n        {\n            const sprite = elements[i];\n            const tex = sprite._texture.baseTexture;\n            const spriteBlendMode = premultiplyBlendMode[\n                tex.alphaMode ? 1 : 0][sprite.blendMode];\n\n            elements[i] = null;\n\n            if (start < i && drawCall.blend !== spriteBlendMode)\n            {\n                drawCall.size = iIndex - drawCall.start;\n                start = i;\n                drawCall = drawCalls[++dcIndex];\n                drawCall.texArray = texArray;\n                drawCall.start = iIndex;\n            }\n\n            this.packInterleavedGeometry(sprite, _attributeBuffer, _indexBuffer, aIndex, iIndex);\n            aIndex += sprite.vertexData.length / 2 * vertexSize;\n            iIndex += sprite.indices.length;\n\n            drawCall.blend = spriteBlendMode;\n        }\n\n        if (start < finish)\n        {\n            drawCall.size = iIndex - drawCall.start;\n            ++dcIndex;\n        }\n\n        this._dcIndex = dcIndex;\n        this._aIndex = aIndex;\n        this._iIndex = iIndex;\n    }\n\n    /**\n     * Bind textures for current rendering\n     * @param texArray\n     */\n    bindAndClearTexArray(texArray: BatchTextureArray): void\n    {\n        const textureSystem = this.renderer.texture;\n\n        for (let j = 0; j < texArray.count; j++)\n        {\n            textureSystem.bind(texArray.elements[j], texArray.ids[j]);\n            texArray.elements[j] = null;\n        }\n        texArray.count = 0;\n    }\n\n    updateGeometry(): void\n    {\n        const {\n            _packedGeometries: packedGeometries,\n            _attributeBuffer: attributeBuffer,\n            _indexBuffer: indexBuffer,\n        } = this;\n\n        if (!settings.CAN_UPLOAD_SAME_BUFFER)\n        { /* Usually on iOS devices, where the browser doesn't\n            like uploads to the same buffer in a single frame. */\n            if (this._packedGeometryPoolSize <= this._flushId)\n            {\n                this._packedGeometryPoolSize++;\n                packedGeometries[this._flushId] = new (this.geometryClass)();\n            }\n\n            packedGeometries[this._flushId]._buffer.update(attributeBuffer.rawBinaryData);\n            packedGeometries[this._flushId]._indexBuffer.update(indexBuffer);\n\n            this.renderer.geometry.bind(packedGeometries[this._flushId]);\n            this.renderer.geometry.updateBuffers();\n            this._flushId++;\n        }\n        else\n        {\n            // lets use the faster option, always use buffer number 0\n            packedGeometries[this._flushId]._buffer.update(attributeBuffer.rawBinaryData);\n            packedGeometries[this._flushId]._indexBuffer.update(indexBuffer);\n\n            this.renderer.geometry.updateBuffers();\n        }\n    }\n\n    drawBatches(): void\n    {\n        const dcCount = this._dcIndex;\n        const { gl, state: stateSystem } = this.renderer;\n        const drawCalls = BatchRenderer._drawCallPool;\n\n        let curTexArray = null;\n\n        // Upload textures and do the draw calls\n        for (let i = 0; i < dcCount; i++)\n        {\n            const { texArray, type, size, start, blend } = drawCalls[i];\n\n            if (curTexArray !== texArray)\n            {\n                curTexArray = texArray;\n                this.bindAndClearTexArray(texArray);\n            }\n\n            this.state.blendMode = blend;\n            stateSystem.set(this.state);\n            gl.drawElements(type, size, gl.UNSIGNED_SHORT, start * 2);\n        }\n    }\n\n    /** Renders the content _now_ and empties the current batch. */\n    flush(): void\n    {\n        if (this._vertexCount === 0)\n        {\n            return;\n        }\n\n        this._attributeBuffer = this.getAttributeBuffer(this._vertexCount);\n        this._indexBuffer = this.getIndexBuffer(this._indexCount);\n        this._aIndex = 0;\n        this._iIndex = 0;\n        this._dcIndex = 0;\n\n        this.buildTexturesAndDrawCalls();\n        this.updateGeometry();\n        this.drawBatches();\n\n        // reset elements buffer for the next flush\n        this._bufferSize = 0;\n        this._vertexCount = 0;\n        this._indexCount = 0;\n    }\n\n    /** Starts a new sprite batch. */\n    start(): void\n    {\n        this.renderer.state.set(this.state);\n\n        this.renderer.texture.ensureSamplerType(this.MAX_TEXTURES);\n\n        this.renderer.shader.bind(this._shader);\n\n        if (settings.CAN_UPLOAD_SAME_BUFFER)\n        {\n            // bind buffer #0, we don't need others\n            this.renderer.geometry.bind(this._packedGeometries[this._flushId]);\n        }\n    }\n\n    /** Stops and flushes the current batch. */\n    stop(): void\n    {\n        this.flush();\n    }\n\n    /** Destroys this `BatchRenderer`. It cannot be used again. */\n    destroy(): void\n    {\n        for (let i = 0; i < this._packedGeometryPoolSize; i++)\n        {\n            if (this._packedGeometries[i])\n            {\n                this._packedGeometries[i].destroy();\n            }\n        }\n\n        this.renderer.off('prerender', this.onPrerender, this);\n\n        this._aBuffers = null;\n        this._iBuffers = null;\n        this._packedGeometries = null;\n        this._attributeBuffer = null;\n        this._indexBuffer = null;\n\n        if (this._shader)\n        {\n            this._shader.destroy();\n            this._shader = null;\n        }\n\n        super.destroy();\n    }\n\n    /**\n     * Fetches an attribute buffer from `this._aBuffers` that can hold atleast `size` floats.\n     * @param size - minimum capacity required\n     * @returns - buffer than can hold atleast `size` floats\n     */\n    getAttributeBuffer(size: number): ViewableBuffer\n    {\n        // 8 vertices is enough for 2 quads\n        const roundedP2 = nextPow2(Math.ceil(size / 8));\n        const roundedSizeIndex = log2(roundedP2);\n        const roundedSize = roundedP2 * 8;\n\n        if (this._aBuffers.length <= roundedSizeIndex)\n        {\n            this._iBuffers.length = roundedSizeIndex + 1;\n        }\n\n        let buffer = this._aBuffers[roundedSize];\n\n        if (!buffer)\n        {\n            this._aBuffers[roundedSize] = buffer = new ViewableBuffer(roundedSize * this.vertexSize * 4);\n        }\n\n        return buffer;\n    }\n\n    /**\n     * Fetches an index buffer from `this._iBuffers` that can\n     * have at least `size` capacity.\n     * @param size - minimum required capacity\n     * @returns - buffer that can fit `size` indices.\n     */\n    getIndexBuffer(size: number): Uint16Array\n    {\n        // 12 indices is enough for 2 quads\n        const roundedP2 = nextPow2(Math.ceil(size / 12));\n        const roundedSizeIndex = log2(roundedP2);\n        const roundedSize = roundedP2 * 12;\n\n        if (this._iBuffers.length <= roundedSizeIndex)\n        {\n            this._iBuffers.length = roundedSizeIndex + 1;\n        }\n\n        let buffer = this._iBuffers[roundedSizeIndex];\n\n        if (!buffer)\n        {\n            this._iBuffers[roundedSizeIndex] = buffer = new Uint16Array(roundedSize);\n        }\n\n        return buffer;\n    }\n\n    /**\n     * Takes the four batching parameters of `element`, interleaves\n     * and pushes them into the batching attribute/index buffers given.\n     *\n     * It uses these properties: `vertexData` `uvs`, `textureId` and\n     * `indicies`. It also uses the \"tint\" of the base-texture, if\n     * present.\n     * @param {PIXI.DisplayObject} element - element being rendered\n     * @param attributeBuffer - attribute buffer.\n     * @param indexBuffer - index buffer\n     * @param aIndex - number of floats already in the attribute buffer\n     * @param iIndex - number of indices already in `indexBuffer`\n     */\n    packInterleavedGeometry(element: IBatchableElement, attributeBuffer: ViewableBuffer, indexBuffer: Uint16Array,\n        aIndex: number, iIndex: number): void\n    {\n        const {\n            uint32View,\n            float32View,\n        } = attributeBuffer;\n\n        const packedVertices = aIndex / this.vertexSize;\n        const uvs = element.uvs;\n        const indicies = element.indices;\n        const vertexData = element.vertexData;\n        const textureId = element._texture.baseTexture._batchLocation;\n\n        const alpha = Math.min(element.worldAlpha, 1.0);\n        const argb = (alpha < 1.0\n            && element._texture.baseTexture.alphaMode)\n            ? premultiplyTint(element._tintRGB, alpha)\n            : element._tintRGB + (alpha * 255 << 24);\n\n        // lets not worry about tint! for now..\n        for (let i = 0; i < vertexData.length; i += 2)\n        {\n            float32View[aIndex++] = vertexData[i];\n            float32View[aIndex++] = vertexData[i + 1];\n            float32View[aIndex++] = uvs[i];\n            float32View[aIndex++] = uvs[i + 1];\n            uint32View[aIndex++] = argb;\n            float32View[aIndex++] = textureId;\n        }\n\n        for (let i = 0; i < indicies.length; i++)\n        {\n            indexBuffer[iIndex++] = packedVertices + indicies[i];\n        }\n    }\n\n    /**\n     * Pool of `BatchDrawCall` objects that `flush` used\n     * to create \"batches\" of the objects being rendered.\n     *\n     * These are never re-allocated again.\n     * Shared between all batch renderers because it can be only one \"flush\" working at the moment.\n     * @member {PIXI.BatchDrawCall[]}\n     */\n    static _drawCallPool: Array<BatchDrawCall> = [];\n\n    /**\n     * Pool of `BatchDrawCall` objects that `flush` used\n     * to create \"batches\" of the objects being rendered.\n     *\n     * These are never re-allocated again.\n     * Shared between all batch renderers because it can be only one \"flush\" working at the moment.\n     * @member {PIXI.BatchTextureArray[]}\n     */\n    static _textureArrayPool: Array<BatchTextureArray> = [];\n}\n\n// Install BatchRenderer as default\nextensions.add(BatchRenderer);\n"],"names":["ObjectRenderer","BatchGeometry","State","settings","defaultVertex","defaultFragment","BatchShaderGenerator","ENV","checkMaxIfStatementsInShader","BatchDrawCall","BatchTextureArray","BaseTexture","premultiplyBlendMode","nextPow2","log2","ViewableBuffer","premultiplyTint","ExtensionType","extensions"],"mappings":"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"}