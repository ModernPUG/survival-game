{"version":3,"file":"TextFormat.mjs","sources":["../../src/formats/TextFormat.ts"],"sourcesContent":["import { BitmapFontData } from '../BitmapFontData';\n\n/**\n * Internal data format used to convert to BitmapFontData.\n * @private\n */\nexport interface IBitmapFontRawData\n{\n    info: {\n        face: string;\n        size: string;\n    }[];\n    common: { lineHeight: string }[];\n    page: {\n        id: string;\n        file: string;\n    }[];\n    chars: {\n        count: number;\n    }[];\n    char: {\n        id: string;\n        page: string;\n        x: string;\n        y: string;\n        width: string;\n        height: string;\n        xoffset: string;\n        yoffset: string;\n        xadvance: string;\n    }[];\n    kernings?: {\n        count: number;\n    }[];\n    kerning?: {\n        first: string;\n        second: string;\n        amount: string;\n    }[];\n    distanceField?: {\n        fieldType: string;\n        distanceRange: string;\n    }[]\n}\n\n/**\n * BitmapFont format that's Text-based.\n * @private\n */\nexport class TextFormat\n{\n    /**\n     * Check if resource refers to txt font data.\n     * @param data\n     * @returns - True if resource could be treated as font data, false otherwise.\n     */\n    static test(data: unknown): boolean\n    {\n        return typeof data === 'string' && data.startsWith('info face=');\n    }\n\n    /**\n     * Convert text font data to a javascript object.\n     * @param txt - Raw string data to be converted\n     * @returns - Parsed font data\n     */\n    static parse(txt: string): BitmapFontData\n    {\n        // Retrieve data item\n        const items = txt.match(/^[a-z]+\\s+.+$/gm);\n        const rawData: IBitmapFontRawData = {\n            info: [],\n            common: [],\n            page: [],\n            char: [],\n            chars: [],\n            kerning: [],\n            kernings: [],\n            distanceField: [],\n        };\n\n        for (const i in items)\n        {\n            // Extract item name\n            const name = items[i].match(/^[a-z]+/gm)[0] as keyof BitmapFontData;\n\n            // Extract item attribute list as string ex.: \"width=10\"\n            const attributeList = items[i].match(/[a-zA-Z]+=([^\\s\"']+|\"([^\"]*)\")/gm);\n\n            // Convert attribute list into an object\n            const itemData: any = {};\n\n            for (const i in attributeList)\n            {\n                // Split key-value pairs\n                const split = attributeList[i].split('=');\n                const key = split[0];\n\n                // Remove eventual quotes from value\n                const strValue = split[1].replace(/\"/gm, '');\n\n                // Try to convert value into float\n                const floatValue = parseFloat(strValue);\n\n                // Use string value case float value is NaN\n                const value = isNaN(floatValue) ? strValue : floatValue;\n\n                itemData[key] = value;\n            }\n\n            // Push current item to the resulting data\n            rawData[name].push(itemData);\n        }\n\n        const font = new BitmapFontData();\n\n        rawData.info.forEach((info) => font.info.push({\n            face: info.face,\n            size: parseInt(info.size, 10),\n        }));\n\n        rawData.common.forEach((common) => font.common.push({\n            lineHeight: parseInt(common.lineHeight, 10),\n        }));\n\n        rawData.page.forEach((page) => font.page.push({\n            id: parseInt(page.id, 10),\n            file: page.file,\n        }));\n\n        rawData.char.forEach((char) => font.char.push({\n            id: parseInt(char.id, 10),\n            page: parseInt(char.page, 10),\n            x: parseInt(char.x, 10),\n            y: parseInt(char.y, 10),\n            width: parseInt(char.width, 10),\n            height: parseInt(char.height, 10),\n            xoffset: parseInt(char.xoffset, 10),\n            yoffset: parseInt(char.yoffset, 10),\n            xadvance: parseInt(char.xadvance, 10),\n        }));\n\n        rawData.kerning.forEach((kerning) => font.kerning.push({\n            first: parseInt(kerning.first, 10),\n            second: parseInt(kerning.second, 10),\n            amount: parseInt(kerning.amount, 10),\n        }));\n\n        rawData.distanceField.forEach((df) => font.distanceField.push({\n            distanceRange: parseInt(df.distanceRange, 10),\n            fieldType: df.fieldType,\n        }));\n\n        return font;\n    }\n}\n"],"names":[],"mappings":"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"}