{"version":3,"file":"Cache.mjs","sources":["../../src/cache/Cache.ts"],"sourcesContent":["import { BaseTexture, Texture } from '@pixi/core';\nimport { convertToList } from '../utils';\nimport type { CacheParser } from './CacheParser';\n\n/**\n * A single Cache for all assets.\n *\n * When assets are added to the cache via set they normally are added to the cache as key-value pairs.\n *\n * With this cache, you can add parsers that will take the object and convert it to a list of assets that can be cached.\n * for example a cacheSprite Sheet parser will add all of the textures found within its sprite sheet directly to the cache.\n *\n * This gives devs the flexibility to cache any type of object however we want.\n *\n * It is not intended that this class is created by developers - it is part of the Asset package.\n * This is the first major system of PixiJS' main Assets class.\n * @memberof PIXI\n * @class Cache\n */\nclass CacheClass\n{\n    private _parsers: CacheParser[] = [];\n\n    private readonly _cache: Map<string, any> = new Map();\n    private readonly _cacheMap: Map<string, {\n        keys: string[],\n        cacheKeys: string[],\n    }> = new Map();\n\n    /** Clear all entries. */\n    public reset(): void\n    {\n        this._cacheMap.clear();\n        this._cache.clear();\n    }\n\n    /**\n     * Check if the key exists\n     * @param key - The key to check\n     */\n    public has(key: string): boolean\n    {\n        return this._cache.has(key);\n    }\n\n    /**\n     * Fetch entry by key\n     * @param key - The key of the entry to get\n     */\n    public get<T = any>(key: string): T\n    {\n        const result = this._cache.get(key);\n\n        if (!result)\n        {\n            // #if _DEBUG\n            console.warn(`[Assets] Asset id ${key} was not found in the Cache`);\n            // #endif\n        }\n\n        return result as T;\n    }\n\n    /**\n     * Set a value by key or keys name\n     * @param key - The key or keys to set\n     * @param value - The value to store in the cache or from which cacheable assets will be derived.\n     */\n    public set(key: string | string[], value: unknown): void\n    {\n        const keys = convertToList<string>(key);\n\n        let cacheableAssets: Record<string, any>;\n\n        for (let i = 0; i < this.parsers.length; i++)\n        {\n            const parser = this.parsers[i];\n\n            if (parser.test(value))\n            {\n                cacheableAssets = parser.getCacheableAssets(keys, value);\n\n                break;\n            }\n        }\n\n        if (!cacheableAssets)\n        {\n            cacheableAssets = {};\n\n            keys.forEach((key) =>\n            {\n                cacheableAssets[key] = value;\n            });\n        }\n\n        const cacheKeys = Object.keys(cacheableAssets);\n\n        const cachedAssets = {\n            cacheKeys,\n            keys\n        };\n\n        // this is so we can remove them later..\n        keys.forEach((key) =>\n        {\n            this._cacheMap.set(key, cachedAssets);\n        });\n\n        cacheKeys.forEach((key) =>\n        {\n            if (this._cache.has(key) && this._cache.get(key) !== value)\n            {\n                // #if _DEBUG\n                console.warn('[Cache] already has key:', key);\n                // #endif\n            }\n\n            this._cache.set(key, cacheableAssets[key]);\n        });\n\n        // temporary to keep compatible with existing texture caching.. until we remove them!\n        if (value instanceof Texture)\n        {\n            const texture: Texture = value;\n\n            keys.forEach((key) =>\n            {\n                if (texture.baseTexture !== Texture.EMPTY.baseTexture)\n                {\n                    BaseTexture.addToCache(texture.baseTexture, key);\n                }\n\n                Texture.addToCache(texture, key);\n            });\n        }\n    }\n\n    /**\n     * Remove entry by key\n     *\n     * This function will also remove any associated alias from the cache also.\n     * @param key - The key of the entry to remove\n     */\n    public remove(key: string): void\n    {\n        this._cacheMap.get(key);\n\n        if (!this._cacheMap.has(key))\n        {\n            // #if _DEBUG\n            console.warn(`[Assets] Asset id ${key} was not found in the Cache`);\n            // #endif\n\n            return;\n        }\n\n        const cacheMap = this._cacheMap.get(key);\n\n        const cacheKeys = cacheMap.cacheKeys;\n\n        cacheKeys.forEach((key) =>\n        {\n            this._cache.delete(key);\n        });\n\n        cacheMap.keys.forEach((key: string) =>\n        {\n            this._cacheMap.delete(key);\n        });\n    }\n\n    /** All loader parsers registered */\n    public get parsers(): CacheParser[]\n    {\n        return this._parsers;\n    }\n}\n\nexport const Cache = new CacheClass();\n"],"names":[],"mappings":"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"}