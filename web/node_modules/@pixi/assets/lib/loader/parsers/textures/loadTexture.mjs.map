{"version":3,"file":"loadTexture.mjs","sources":["../../../../src/loader/parsers/textures/loadTexture.ts"],"sourcesContent":["import { BaseTexture, extensions, ExtensionType, settings, utils } from '@pixi/core';\nimport { LoaderParserPriority } from '../LoaderParser';\nimport { WorkerManager } from '../WorkerManager';\nimport { checkExtension } from './utils/checkExtension';\nimport { createTexture } from './utils/createTexture';\n\nimport type { IBaseTextureOptions, Texture } from '@pixi/core';\nimport type { Loader } from '../../Loader';\nimport type { LoadAsset } from '../../types';\nimport type { LoaderParser } from '../LoaderParser';\n\nconst validImages = ['.jpg', '.png', '.jpeg', '.avif', '.webp'];\n\n/**\n * Returns a promise that resolves an ImageBitmaps.\n * This function is designed to be used by a worker.\n * Part of WorkerManager!\n * @param url - The image to load an image bitmap for\n */\nexport async function loadImageBitmap(url: string): Promise<ImageBitmap>\n{\n    const response = await settings.ADAPTER.fetch(url);\n\n    if (!response.ok)\n    {\n        throw new Error(`[loadImageBitmap] Failed to fetch ${url}: `\n            + `${response.status} ${response.statusText}`);\n    }\n\n    const imageBlob = await response.blob();\n    const imageBitmap = await createImageBitmap(imageBlob);\n\n    return imageBitmap;\n}\n\n/**\n * Loads our textures!\n * this makes use of imageBitmaps where available.\n * We load the ImageBitmap on a different thread using the WorkerManager\n * We can then use the ImageBitmap as a source for a Pixi Texture\n */\nexport const loadTextures = {\n    extension: {\n        type: ExtensionType.LoadParser,\n        priority: LoaderParserPriority.High,\n    },\n\n    config: {\n        preferWorkers: true,\n    },\n\n    test(url: string): boolean\n    {\n        let isValidBase64Suffix = false;\n\n        for (let i = 0; i < validImages.length; i++)\n        {\n            if (url.startsWith(`data:image/${validImages[i].slice(1)}`))\n            {\n                isValidBase64Suffix = true;\n                break;\n            }\n        }\n\n        return isValidBase64Suffix || checkExtension(url, validImages);\n    },\n\n    async load(url: string, asset: LoadAsset<IBaseTextureOptions>, loader: Loader): Promise<Texture>\n    {\n        let src: any = null;\n\n        if (globalThis.createImageBitmap)\n        {\n            if (this.config.preferWorkers && await WorkerManager.isImageBitmapSupported())\n            {\n                src = await WorkerManager.loadImageBitmap(url);\n            }\n            else\n            {\n                src = await loadImageBitmap(url);\n            }\n        }\n        else\n        {\n            src = await new Promise((resolve) =>\n            {\n                src = new Image();\n                src.crossOrigin = 'anonymous';\n\n                src.src = url;\n                if (src.complete)\n                {\n                    resolve(src);\n                }\n                else\n                {\n                    src.onload = (): void =>\n                    {\n                        resolve(src);\n                    };\n                }\n            });\n        }\n\n        const base = new BaseTexture(src, {\n            resolution: utils.getResolutionOfUrl(url),\n            ...asset.data,\n        });\n\n        base.resource.src = url;\n\n        return createTexture(base, loader, url);\n    },\n\n    unload(texture: Texture): void\n    {\n        texture.destroy(true);\n    }\n} as LoaderParser<Texture, IBaseTextureOptions>;\n\nextensions.add(loadTextures);\n"],"names":[],"mappings":"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"}