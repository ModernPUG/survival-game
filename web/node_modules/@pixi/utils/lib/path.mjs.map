{"version":3,"file":"path.mjs","sources":["../src/path.ts"],"sourcesContent":["import { settings } from '@pixi/settings';\n\nfunction assertPath(path: string)\n{\n    if (typeof path !== 'string')\n    {\n        throw new TypeError(`Path must be a string. Received ${JSON.stringify(path)}`);\n    }\n}\n\nfunction removeUrlParams(url: string): string\n{\n    const re = url.split('?')[0];\n\n    return re.split('#')[0];\n}\n\nfunction escapeRegExp(string: string)\n{\n    return string.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&'); // $& means the whole matched string\n}\n\nfunction replaceAll(str: string, find: string, replace: string)\n{\n    return str.replace(new RegExp(escapeRegExp(find), 'g'), replace);\n}\n\n// Resolves . and .. elements in a path with directory names\nfunction normalizeStringPosix(path: string, allowAboveRoot: boolean)\n{\n    let res = '';\n    let lastSegmentLength = 0;\n    let lastSlash = -1;\n    let dots = 0;\n    let code: number;\n\n    for (let i = 0; i <= path.length; ++i)\n    {\n        if (i < path.length)\n        {\n            code = path.charCodeAt(i);\n        }\n        else if (code === 47)\n        {\n            break;\n        }\n        else\n        {\n            code = 47;\n        }\n        if (code === 47)\n        {\n            if (lastSlash === i - 1 || dots === 1)\n            {\n                // NOOP\n            }\n            else if (lastSlash !== i - 1 && dots === 2)\n            {\n                if (\n                    res.length < 2\n                    || lastSegmentLength !== 2\n                    || res.charCodeAt(res.length - 1) !== 46\n                    || res.charCodeAt(res.length - 2) !== 46\n                )\n                {\n                    if (res.length > 2)\n                    {\n                        const lastSlashIndex = res.lastIndexOf('/');\n\n                        if (lastSlashIndex !== res.length - 1)\n                        {\n                            if (lastSlashIndex === -1)\n                            {\n                                res = '';\n                                lastSegmentLength = 0;\n                            }\n                            else\n                            {\n                                res = res.slice(0, lastSlashIndex);\n                                lastSegmentLength = res.length - 1 - res.lastIndexOf('/');\n                            }\n                            lastSlash = i;\n                            dots = 0;\n                            continue;\n                        }\n                    }\n                    else if (res.length === 2 || res.length === 1)\n                    {\n                        res = '';\n                        lastSegmentLength = 0;\n                        lastSlash = i;\n                        dots = 0;\n                        continue;\n                    }\n                }\n                if (allowAboveRoot)\n                {\n                    if (res.length > 0)\n                    { res += '/..'; }\n                    else\n                    { res = '..'; }\n                    lastSegmentLength = 2;\n                }\n            }\n            else\n            {\n                if (res.length > 0)\n                {\n                    res += `/${path.slice(lastSlash + 1, i)}`;\n                }\n                else\n                {\n                    res = path.slice(lastSlash + 1, i);\n                }\n                lastSegmentLength = i - lastSlash - 1;\n            }\n            lastSlash = i;\n            dots = 0;\n        }\n        else if (code === 46 && dots !== -1)\n        {\n            ++dots;\n        }\n        else\n        {\n            dots = -1;\n        }\n    }\n\n    return res;\n}\n\nexport interface Path\n{\n    toPosix: (path: string) => string;\n    toAbsolute: (url: string, baseUrl?: string, rootUrl?: string) => string;\n    isUrl: (path: string) => boolean;\n    isDataUrl: (path: string) => boolean;\n    hasProtocol: (path: string) => boolean;\n    getProtocol: (path: string) => string;\n    normalize: (path: string) => string;\n    join: (...paths: string[]) => string;\n    isAbsolute: (path: string) => boolean;\n    dirname: (path: string) => string;\n    rootname: (path: string) => string;\n    basename: (path: string, ext?: string) => string;\n    extname: (path: string) => string;\n    parse: (path: string) => { root?: string, dir?: string, base?: string, ext?: string, name?: string };\n    sep: string,\n    delimiter: string\n}\n\nexport const path: Path = {\n    /**\n     * Converts a path to posix format.\n     * @param path - The path to convert to posix\n     */\n    toPosix(path: string) { return replaceAll(path, '\\\\', '/'); },\n    /**\n     * Checks if the path is a URL\n     * @param path - The path to check\n     */\n    isUrl(path: string) { return (/^https?:/).test(this.toPosix(path)); },\n    /**\n     * Checks if the path is a data URL\n     * @param path - The path to check\n     */\n    isDataUrl(path: string)\n    {\n        // eslint-disable-next-line max-len\n        return (/^data:([a-z]+\\/[a-z0-9-+.]+(;[a-z0-9-.!#$%*+.{}|~`]+=[a-z0-9-.!#$%*+.{}()_|~`]+)*)?(;base64)?,([a-z0-9!$&',()*+;=\\-._~:@\\/?%\\s<>]*?)$/i)\n            .test(path);\n    },\n    /**\n     * Checks if the path has a protocol e.g. http://\n     * This will return true for windows file paths\n     * @param path - The path to check\n     */\n    hasProtocol(path: string) { return (/^[^/:]+:\\//).test(this.toPosix(path)); },\n    /**\n     * Returns the protocol of the path e.g. http://, C:/, file:///\n     * @param path - The path to get the protocol from\n     */\n    getProtocol(path: string)\n    {\n        assertPath(path);\n        path = this.toPosix(path);\n\n        let protocol = '';\n\n        const isFile = (/^file:\\/\\/\\//).exec(path);\n        const isHttp = (/^[^/:]+:\\/\\//).exec(path);\n        const isWindows = (/^[^/:]+:\\//).exec(path);\n\n        if (isFile || isHttp || isWindows)\n        {\n            const arr = isFile?.[0] || isHttp?.[0] || isWindows?.[0];\n\n            protocol = arr;\n            path = path.slice(arr.length);\n        }\n\n        return protocol;\n    },\n\n    /**\n     * Converts URL to an absolute path.\n     * When loading from a Web Worker, we must use absolute paths.\n     * If the URL is already absolute we return it as is\n     * If it's not, we convert it\n     * @param url - The URL to test\n     * @param customBaseUrl - The base URL to use\n     * @param customRootUrl - The root URL to use\n     */\n    toAbsolute(url: string, customBaseUrl?: string, customRootUrl?: string)\n    {\n        if (this.isDataUrl(url)) return url;\n\n        const baseUrl = removeUrlParams(this.toPosix(customBaseUrl ?? settings.ADAPTER.getBaseUrl()));\n        const rootUrl = removeUrlParams(this.toPosix(customRootUrl ?? this.rootname(baseUrl)));\n\n        assertPath(url);\n        url = this.toPosix(url);\n\n        // root relative url\n        if (url.startsWith('/'))\n        {\n            return path.join(rootUrl, url.slice(1));\n        }\n\n        const absolutePath = this.isAbsolute(url) ? url : this.join(baseUrl, url);\n\n        return absolutePath;\n    },\n\n    /**\n     * Normalizes the given path, resolving '..' and '.' segments\n     * @param path - The path to normalize\n     */\n    normalize(path: string)\n    {\n        path = this.toPosix(path);\n        assertPath(path);\n\n        if (path.length === 0) return '.';\n\n        let protocol = '';\n        const isAbsolute = path.startsWith('/');\n\n        if (this.hasProtocol(path))\n        {\n            protocol = this.rootname(path);\n            path = path.slice(protocol.length);\n        }\n\n        const trailingSeparator = path.endsWith('/');\n\n        // Normalize the path\n        path = normalizeStringPosix(path, false);\n\n        if (path.length > 0 && trailingSeparator) path += '/';\n        if (isAbsolute) return `/${path}`;\n\n        return protocol + path;\n    },\n\n    /**\n     * Determines if path is an absolute path.\n     * Absolute paths can be urls, data urls, or paths on disk\n     * @param path - The path to test\n     */\n    isAbsolute(path: string)\n    {\n        assertPath(path);\n        path = this.toPosix(path);\n\n        if (this.hasProtocol(path)) return true;\n\n        return path.startsWith('/');\n    },\n\n    /**\n     * Joins all given path segments together using the platform-specific separator as a delimiter,\n     * then normalizes the resulting path\n     * @param segments - The segments of the path to join\n     */\n    join(...segments: string[])\n    {\n        if (segments.length === 0)\n        { return '.'; }\n        let joined;\n\n        for (let i = 0; i < segments.length; ++i)\n        {\n            const arg = segments[i];\n\n            assertPath(arg);\n            if (arg.length > 0)\n            {\n                if (joined === undefined) joined = arg;\n                else\n                {\n                    const prevArg = segments[i - 1] ?? '';\n\n                    if (this.extname(prevArg))\n                    {\n                        joined += `/../${arg}`;\n                    }\n                    else\n                    {\n                        joined += `/${arg}`;\n                    }\n                }\n            }\n        }\n        if (joined === undefined) { return '.'; }\n\n        return this.normalize(joined);\n    },\n\n    /**\n     * Returns the directory name of a path\n     * @param path - The path to parse\n     */\n    dirname(path: string)\n    {\n        assertPath(path);\n        if (path.length === 0) return '.';\n        path = this.toPosix(path);\n        let code = path.charCodeAt(0);\n        const hasRoot = code === 47;\n        let end = -1;\n        let matchedSlash = true;\n\n        const proto = this.getProtocol(path);\n        const origpath = path;\n\n        path = path.slice(proto.length);\n\n        for (let i = path.length - 1; i >= 1; --i)\n        {\n            code = path.charCodeAt(i);\n            if (code === 47)\n            {\n                if (!matchedSlash)\n                {\n                    end = i;\n                    break;\n                }\n            }\n            else\n            {\n                // We saw the first non-path separator\n                matchedSlash = false;\n            }\n        }\n\n        // if end is -1 and its a url then we need to add the path back\n        // eslint-disable-next-line no-nested-ternary\n        if (end === -1) return hasRoot ? '/' : this.isUrl(origpath) ? proto + path : proto;\n        if (hasRoot && end === 1) return '//';\n\n        return proto + path.slice(0, end);\n    },\n\n    /**\n     * Returns the root of the path e.g. /, C:/, file:///, http://domain.com/\n     * @param path - The path to parse\n     */\n    rootname(path: string)\n    {\n        assertPath(path);\n        path = this.toPosix(path);\n\n        let root = '';\n\n        if (path.startsWith('/')) root = '/';\n        else\n        {\n            root = this.getProtocol(path);\n        }\n\n        if (this.isUrl(path))\n        {\n            // need to find the first path separator\n            const index = path.indexOf('/', root.length);\n\n            if (index !== -1)\n            {\n                root = path.slice(0, index);\n            }\n            else root = path;\n\n            if (!root.endsWith('/')) root += '/';\n        }\n\n        return root;\n    },\n\n    /**\n     * Returns the last portion of a path\n     * @param path - The path to test\n     * @param ext - Optional extension to remove\n     */\n    basename(path: string, ext?: string)\n    {\n        assertPath(path);\n        if (ext) assertPath(ext);\n\n        path = this.toPosix(path);\n\n        let start = 0;\n        let end = -1;\n        let matchedSlash = true;\n        let i: number;\n\n        if (ext !== undefined && ext.length > 0 && ext.length <= path.length)\n        {\n            if (ext.length === path.length && ext === path) return '';\n            let extIdx = ext.length - 1;\n            let firstNonSlashEnd = -1;\n\n            for (i = path.length - 1; i >= 0; --i)\n            {\n                const code = path.charCodeAt(i);\n\n                if (code === 47)\n                {\n                    // If we reached a path separator that was not part of a set of path\n                    // separators at the end of the string, stop now\n                    if (!matchedSlash)\n                    {\n                        start = i + 1;\n                        break;\n                    }\n                }\n                else\n                {\n                    if (firstNonSlashEnd === -1)\n                    {\n                        // We saw the first non-path separator, remember this index in case\n                        // we need it if the extension ends up not matching\n                        matchedSlash = false;\n                        firstNonSlashEnd = i + 1;\n                    }\n                    if (extIdx >= 0)\n                    {\n                        // Try to match the explicit extension\n                        if (code === ext.charCodeAt(extIdx))\n                        {\n                            if (--extIdx === -1)\n                            {\n                                // We matched the extension, so mark this as the end of our path\n                                // component\n                                end = i;\n                            }\n                        }\n                        else\n                        {\n                            // Extension does not match, so our result is the entire path\n                            // component\n                            extIdx = -1;\n                            end = firstNonSlashEnd;\n                        }\n                    }\n                }\n            }\n\n            if (start === end) end = firstNonSlashEnd; else if (end === -1) end = path.length;\n\n            return path.slice(start, end);\n        }\n        for (i = path.length - 1; i >= 0; --i)\n        {\n            if (path.charCodeAt(i) === 47)\n            {\n                // If we reached a path separator that was not part of a set of path\n                // separators at the end of the string, stop now\n                if (!matchedSlash)\n                {\n                    start = i + 1;\n                    break;\n                }\n            }\n            else if (end === -1)\n            {\n                // We saw the first non-path separator, mark this as the end of our\n                // path component\n                matchedSlash = false;\n                end = i + 1;\n            }\n        }\n\n        if (end === -1) return '';\n\n        return path.slice(start, end);\n    },\n\n    /**\n     * Returns the extension of the path, from the last occurrence of the . (period) character to end of string in the last\n     * portion of the path. If there is no . in the last portion of the path, or if there are no . characters other than\n     * the first character of the basename of path, an empty string is returned.\n     * @param path - The path to parse\n     */\n    extname(path: string)\n    {\n        assertPath(path);\n        path = this.toPosix(path);\n\n        let startDot = -1;\n        let startPart = 0;\n        let end = -1;\n        let matchedSlash = true;\n        // Track the state of characters (if any) we see before our first dot and\n        // after any path separator we find\n        let preDotState = 0;\n\n        for (let i = path.length - 1; i >= 0; --i)\n        {\n            const code = path.charCodeAt(i);\n\n            if (code === 47)\n            {\n                // If we reached a path separator that was not part of a set of path\n                // separators at the end of the string, stop now\n                if (!matchedSlash)\n                {\n                    startPart = i + 1;\n                    break;\n                }\n                continue;\n            }\n            if (end === -1)\n            {\n                // We saw the first non-path separator, mark this as the end of our\n                // extension\n                matchedSlash = false;\n                end = i + 1;\n            }\n            if (code === 46)\n            {\n                // If this is our first dot, mark it as the start of our extension\n                if (startDot === -1) startDot = i;\n                else if (preDotState !== 1) preDotState = 1;\n            }\n            else if (startDot !== -1)\n            {\n                // We saw a non-dot and non-path separator before our dot, so we should\n                // have a good chance at having a non-empty extension\n                preDotState = -1;\n            }\n        }\n\n        if (\n            startDot === -1 || end === -1\n            // We saw a non-dot character immediately before the dot\n            || preDotState === 0\n            // The (right-most) trimmed path component is exactly '..'\n            // eslint-disable-next-line no-mixed-operators\n            || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1\n        )\n        {\n            return '';\n        }\n\n        return path.slice(startDot, end);\n    },\n\n    /**\n     * Parses a path into an object containing the 'root', `dir`, `base`, `ext`, and `name` properties.\n     * @param path - The path to parse\n     */\n    parse(path: string)\n    {\n        assertPath(path);\n\n        const ret = { root: '', dir: '', base: '', ext: '', name: '' };\n\n        if (path.length === 0) return ret;\n        path = this.toPosix(path);\n\n        let code = path.charCodeAt(0);\n        const isAbsolute = this.isAbsolute(path);\n        let start: number;\n        const protocol = '';\n\n        ret.root = this.rootname(path);\n\n        if (isAbsolute || this.hasProtocol(path))\n        {\n            start = 1;\n        }\n        else\n        {\n            start = 0;\n        }\n        let startDot = -1;\n        let startPart = 0;\n        let end = -1;\n        let matchedSlash = true;\n        let i = path.length - 1;\n\n        // Track the state of characters (if any) we see before our first dot and\n        // after any path separator we find\n        let preDotState = 0;\n\n        // Get non-dir info\n        for (; i >= start; --i)\n        {\n            code = path.charCodeAt(i);\n            if (code === 47)\n            {\n                // If we reached a path separator that was not part of a set of path\n                // separators at the end of the string, stop now\n                if (!matchedSlash)\n                {\n                    startPart = i + 1;\n                    break;\n                }\n                continue;\n            }\n            if (end === -1)\n            {\n                // We saw the first non-path separator, mark this as the end of our\n                // extension\n                matchedSlash = false;\n                end = i + 1;\n            }\n            if (code === 46)\n            {\n                // If this is our first dot, mark it as the start of our extension\n                if (startDot === -1) startDot = i;\n                else if (preDotState !== 1) preDotState = 1;\n            }\n            else if (startDot !== -1)\n            {\n                // We saw a non-dot and non-path separator before our dot, so we should\n                // have a good chance at having a non-empty extension\n                preDotState = -1;\n            }\n        }\n\n        if (\n            startDot === -1 || end === -1\n            // We saw a non-dot character immediately before the dot\n            || preDotState === 0\n            // The (right-most) trimmed path component is exactly '..'\n            // eslint-disable-next-line no-mixed-operators\n            || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1\n        )\n        {\n            if (end !== -1)\n            {\n                if (startPart === 0 && isAbsolute) ret.base = ret.name = path.slice(1, end);\n                else ret.base = ret.name = path.slice(startPart, end);\n            }\n        }\n        else\n        {\n            if (startPart === 0 && isAbsolute)\n            {\n                ret.name = path.slice(1, startDot);\n                ret.base = path.slice(1, end);\n            }\n            else\n            {\n                ret.name = path.slice(startPart, startDot);\n                ret.base = path.slice(startPart, end);\n            }\n            ret.ext = path.slice(startDot, end);\n        }\n\n        ret.dir = this.dirname(path);\n        if (protocol) ret.dir = protocol + ret.dir;\n\n        return ret;\n    },\n\n    sep: '/',\n    delimiter: ':'\n} as Path;\n"],"names":[],"mappings":"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"}